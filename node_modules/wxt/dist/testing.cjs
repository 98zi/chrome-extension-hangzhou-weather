"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/testing/index.ts
var testing_exports = {};
__export(testing_exports, {
  WxtVitest: () => WxtVitest,
  fakeBrowser: () => import_fake_browser.fakeBrowser
});
module.exports = __toCommonJS(testing_exports);

// src/testing/fake-browser.ts
var import_fake_browser = require("@webext-core/fake-browser");

// src/core/utils/entrypoints.ts
var import_node_path2 = __toESM(require("path"), 1);

// src/core/utils/paths.ts
var import_node_path = __toESM(require("path"), 1);
var import_normalize_path = __toESM(require("normalize-path"), 1);
function normalizePath(path7) {
  return (0, import_normalize_path.default)(path7);
}
var CSS_EXTENSIONS = ["css", "scss", "sass", "less", "styl", "stylus"];
var CSS_EXTENSIONS_PATTERN = `+(${CSS_EXTENSIONS.join("|")})`;

// src/core/utils/entrypoints.ts
function getEntrypointName(entrypointsDir, inputPath) {
  const relativePath = import_node_path2.default.relative(entrypointsDir, inputPath);
  const name = relativePath.split(/[\.\/\\]/, 2)[0];
  return name;
}
function getEntrypointOutputFile(entrypoint, ext) {
  return (0, import_node_path2.resolve)(entrypoint.outputDir, `${entrypoint.name}${ext}`);
}
function getEntrypointBundlePath(entrypoint, outDir, ext) {
  return normalizePath(
    (0, import_node_path2.relative)(outDir, getEntrypointOutputFile(entrypoint, ext))
  );
}
function isHtmlEntrypoint(entrypoint) {
  return entrypoint.inputPath.endsWith(".html");
}

// src/core/builders/vite/plugins/devHtmlPrerender.ts
var import_linkedom = require("linkedom");
var import_node_path3 = require("path");
var reactRefreshPreamble = "";
function devHtmlPrerender(config) {
  const htmlReloadId = "@wxt/reload-html";
  const resolvedHtmlReloadId = (0, import_node_path3.resolve)(
    config.root,
    "node_modules/wxt/dist/virtual/reload-html.js"
  );
  const virtualReactRefreshId = "@wxt/virtual-react-refresh";
  const resolvedVirtualReactRefreshId = "\0" + virtualReactRefreshId;
  return [
    {
      apply: "build",
      name: "wxt:dev-html-prerender",
      config() {
        return {
          resolve: {
            alias: {
              [htmlReloadId]: resolvedHtmlReloadId
            }
          }
        };
      },
      // Convert scripts like src="./main.tsx" -> src="http://localhost:3000/entrypoints/popup/main.tsx"
      // before the paths are replaced with their bundled path
      transform(code, id) {
        const server = config.server;
        if (config.command !== "serve" || server == null || !id.endsWith(".html"))
          return;
        const { document } = (0, import_linkedom.parseHTML)(code);
        const _pointToDevServer = (querySelector, attr) => pointToDevServer(config, server, id, document, querySelector, attr);
        _pointToDevServer("script[type=module]", "src");
        _pointToDevServer("link[rel=stylesheet]", "href");
        const reloader = document.createElement("script");
        reloader.src = htmlReloadId;
        reloader.type = "module";
        document.head.appendChild(reloader);
        const newHtml = document.toString();
        config.logger.debug("transform " + id);
        config.logger.debug("Old HTML:\n" + code);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      },
      // Pass the HTML through the dev server to add dev-mode specific code
      async transformIndexHtml(html, ctx) {
        const server = config.server;
        if (config.command !== "serve" || server == null)
          return;
        const originalUrl = `${server.origin}${ctx.path}`;
        const name = getEntrypointName(config.entrypointsDir, ctx.filename);
        const url = `${server.origin}/${name}.html`;
        const serverHtml = await server.transformHtml(url, html, originalUrl);
        const { document } = (0, import_linkedom.parseHTML)(serverHtml);
        const reactRefreshScript = Array.from(
          document.querySelectorAll("script[type=module]")
        ).find((script) => script.innerHTML.includes("@react-refresh"));
        if (reactRefreshScript) {
          reactRefreshPreamble = reactRefreshScript.innerHTML;
          const virtualScript = document.createElement("script");
          virtualScript.type = "module";
          virtualScript.src = `${server.origin}/${virtualReactRefreshId}`;
          reactRefreshScript.replaceWith(virtualScript);
        }
        const viteClientScript = document.querySelector(
          "script[src='/@vite/client']"
        );
        if (viteClientScript) {
          viteClientScript.src = `${server.origin}${viteClientScript.src}`;
        }
        const newHtml = document.toString();
        config.logger.debug("transformIndexHtml " + ctx.filename);
        config.logger.debug("Old HTML:\n" + html);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      }
    },
    {
      name: "wxt:virtualize-react-refresh",
      apply: "serve",
      resolveId(id) {
        if (id === `/${virtualReactRefreshId}`) {
          return resolvedVirtualReactRefreshId;
        }
        if (id.startsWith("/chunks/")) {
          return "\0noop";
        }
      },
      load(id) {
        if (id === resolvedVirtualReactRefreshId) {
          return reactRefreshPreamble;
        }
        if (id === "\0noop") {
          return "";
        }
      }
    }
  ];
}
function pointToDevServer(config, server, id, document, querySelector, attr) {
  document.querySelectorAll(querySelector).forEach((element) => {
    const src = element.getAttribute(attr);
    if (!src || isUrl(src))
      return;
    let resolvedAbsolutePath;
    const matchingAlias = Object.entries(config.alias).find(
      ([key]) => src.startsWith(key)
    );
    if (matchingAlias) {
      const [alias, replacement] = matchingAlias;
      resolvedAbsolutePath = (0, import_node_path3.resolve)(
        config.root,
        src.replace(alias, replacement)
      );
    } else {
      resolvedAbsolutePath = (0, import_node_path3.resolve)((0, import_node_path3.dirname)(id), src);
    }
    if (resolvedAbsolutePath) {
      const relativePath = normalizePath(
        (0, import_node_path3.relative)(config.root, resolvedAbsolutePath)
      );
      if (relativePath.startsWith(".")) {
        let path7 = normalizePath(resolvedAbsolutePath);
        if (!path7.startsWith("/"))
          path7 = "/" + path7;
        element.setAttribute(attr, `${server.origin}/@fs${path7}`);
      } else {
        const url = new URL(relativePath, server.origin);
        element.setAttribute(attr, url.href);
      }
    }
  });
}
function isUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}

// src/core/builders/vite/plugins/devServerGlobals.ts
function devServerGlobals(config) {
  return {
    name: "wxt:dev-server-globals",
    config() {
      if (config.server == null || config.command == "build")
        return;
      return {
        define: {
          __DEV_SERVER_PROTOCOL__: JSON.stringify("ws:"),
          __DEV_SERVER_HOSTNAME__: JSON.stringify(config.server.hostname),
          __DEV_SERVER_PORT__: JSON.stringify(config.server.port)
        }
      };
    }
  };
}

// src/core/utils/network.ts
var import_node_dns = __toESM(require("dns"), 1);

// src/core/utils/time.ts
function withTimeout(promise, duration) {
  return new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      rej(`Promise timed out after ${duration}ms`);
    }, duration);
    promise.then(res).catch(rej).finally(() => clearTimeout(timeout));
  });
}

// src/core/utils/network.ts
function isOffline() {
  const isOffline2 = new Promise((res) => {
    import_node_dns.default.resolve("google.com", (err) => {
      if (err == null) {
        res(false);
      } else {
        res(true);
      }
    });
  });
  return withTimeout(isOffline2, 1e3).catch(() => true);
}
async function isOnline() {
  const offline = await isOffline();
  return !offline;
}
async function fetchCached(url, config) {
  let content = "";
  if (await isOnline()) {
    const res = await fetch(url);
    if (res.status < 300) {
      content = await res.text();
      await config.fsCache.set(url, content);
    } else {
      config.logger.debug(
        `Failed to download "${url}", falling back to cache...`
      );
    }
  }
  if (!content)
    content = await config.fsCache.get(url) ?? "";
  if (!content)
    throw Error(
      `Offline and "${url}" has not been cached. Try again when online.`
    );
  return content;
}

// src/core/builders/vite/plugins/download.ts
function download(config) {
  return {
    name: "wxt:download",
    resolveId(id) {
      if (id.startsWith("url:"))
        return "\0" + id;
    },
    async load(id) {
      if (!id.startsWith("\0url:"))
        return;
      const url = id.replace("\0url:", "");
      return await fetchCached(url, config);
    }
  };
}

// src/core/builders/vite/plugins/multipageMove.ts
var import_node_path4 = require("path");
var import_fs_extra = __toESM(require("fs-extra"), 1);
function multipageMove(entrypoints, config) {
  return {
    name: "wxt:multipage-move",
    async writeBundle(_, bundle) {
      for (const oldBundlePath in bundle) {
        const entrypoint = entrypoints.find(
          (entry) => !!normalizePath(entry.inputPath).endsWith(oldBundlePath)
        );
        if (entrypoint == null) {
          config.logger.debug(
            `No entrypoint found for ${oldBundlePath}, leaving in chunks directory`
          );
          continue;
        }
        const newBundlePath = getEntrypointBundlePath(
          entrypoint,
          config.outDir,
          (0, import_node_path4.extname)(oldBundlePath)
        );
        if (newBundlePath === oldBundlePath) {
          config.logger.debug(
            "HTML file is already in the correct location",
            oldBundlePath
          );
          continue;
        }
        const oldAbsPath = (0, import_node_path4.resolve)(config.outDir, oldBundlePath);
        const newAbsPath = (0, import_node_path4.resolve)(config.outDir, newBundlePath);
        await (0, import_fs_extra.ensureDir)((0, import_node_path4.dirname)(newAbsPath));
        await import_fs_extra.default.move(oldAbsPath, newAbsPath, { overwrite: true });
        const renamedChunk = {
          ...bundle[oldBundlePath],
          fileName: newBundlePath
        };
        delete bundle[oldBundlePath];
        bundle[newBundlePath] = renamedChunk;
      }
      removeEmptyDirs(config.outDir);
    }
  };
}
async function removeEmptyDirs(dir) {
  const files = await import_fs_extra.default.readdir(dir);
  for (const file of files) {
    const filePath = (0, import_node_path4.join)(dir, file);
    const stats = await import_fs_extra.default.stat(filePath);
    if (stats.isDirectory()) {
      await removeEmptyDirs(filePath);
    }
  }
  try {
    await import_fs_extra.default.rmdir(dir);
  } catch {
  }
}

// src/core/builders/vite/plugins/unimport.ts
var import_unimport = require("unimport");
var import_path = require("path");
var ENABLED_EXTENSIONS = /* @__PURE__ */ new Set([
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".vue",
  ".svelte"
]);
function unimport(config) {
  const options = config.imports;
  if (options === false)
    return [];
  const unimport2 = (0, import_unimport.createUnimport)(options);
  return {
    name: "wxt:unimport",
    async config() {
      await unimport2.scanImportsFromDir(void 0, { cwd: config.srcDir });
    },
    async transform(code, id) {
      if (id.includes("node_modules"))
        return;
      if (!ENABLED_EXTENSIONS.has((0, import_path.extname)(id)))
        return;
      const injected = await unimport2.injectImports(code, id);
      return {
        code: injected.code,
        map: injected.s.generateMap({ hires: "boundary", source: id })
      };
    }
  };
}

// src/core/builders/vite/plugins/virtualEntrypoint.ts
var import_fs_extra2 = __toESM(require("fs-extra"), 1);
var import_path2 = require("path");
function virtualEntrypoint(type, config) {
  const virtualId = `virtual:wxt-${type}?`;
  const resolvedVirtualId = `\0${virtualId}`;
  return {
    name: `wxt:virtual-entrypoint`,
    resolveId(id) {
      const index = id.indexOf(virtualId);
      if (index === -1)
        return;
      const inputPath = normalizePath(id.substring(index + virtualId.length));
      return resolvedVirtualId + inputPath;
    },
    async load(id) {
      if (!id.startsWith(resolvedVirtualId))
        return;
      const inputPath = id.replace(resolvedVirtualId, "");
      const template = await import_fs_extra2.default.readFile(
        (0, import_path2.resolve)(
          config.root,
          `node_modules/wxt/dist/virtual/${type}-entrypoint.js`
        ),
        "utf-8"
      );
      return template.replace(`virtual:user-${type}`, inputPath);
    }
  };
}

// src/core/builders/vite/plugins/tsconfigPaths.ts
function tsconfigPaths(config) {
  return {
    name: "wxt:aliases",
    async config() {
      return {
        resolve: {
          alias: config.alias
        }
      };
    }
  };
}

// src/core/utils/constants.ts
var VIRTUAL_NOOP_BACKGROUND_MODULE_ID = "virtual:user-background";

// src/core/builders/vite/plugins/noopBackground.ts
function noopBackground() {
  const virtualModuleId = VIRTUAL_NOOP_BACKGROUND_MODULE_ID;
  const resolvedVirtualModuleId = "\0" + virtualModuleId;
  return {
    name: "wxt:noop-background",
    resolveId(id) {
      if (id === virtualModuleId)
        return resolvedVirtualModuleId;
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `import { defineBackground } from 'wxt/sandbox';
export default defineBackground(() => void 0)`;
      }
    }
  };
}

// src/core/builders/vite/plugins/cssEntrypoints.ts
function cssEntrypoints(entrypoint, config) {
  return {
    name: "wxt:css-entrypoint",
    config() {
      return {
        build: {
          rollupOptions: {
            output: {
              assetFileNames: () => getEntrypointBundlePath(entrypoint, config.outDir, ".css")
            }
          }
        }
      };
    },
    generateBundle(_, bundle) {
      Object.keys(bundle).forEach((file) => {
        if (file.endsWith(".js"))
          delete bundle[file];
      });
    }
  };
}

// src/core/builders/vite/plugins/bundleAnalysis.ts
var import_rollup_plugin_visualizer = require("rollup-plugin-visualizer");
var import_node_path5 = __toESM(require("path"), 1);
var increment = 0;
function bundleAnalysis(config) {
  return (0, import_rollup_plugin_visualizer.visualizer)({
    template: "raw-data",
    filename: import_node_path5.default.resolve(
      config.analysis.outputDir,
      `${config.analysis.outputName}-${increment++}.json`
    )
  });
}

// src/core/utils/globals.ts
function getGlobals(config) {
  return [
    {
      name: "MANIFEST_VERSION",
      value: config.manifestVersion,
      type: `2 | 3`
    },
    {
      name: "BROWSER",
      value: config.browser,
      type: `string`
    },
    {
      name: "CHROME",
      value: config.browser === "chrome",
      type: `boolean`
    },
    {
      name: "FIREFOX",
      value: config.browser === "firefox",
      type: `boolean`
    },
    {
      name: "SAFARI",
      value: config.browser === "safari",
      type: `boolean`
    },
    {
      name: "EDGE",
      value: config.browser === "edge",
      type: `boolean`
    },
    {
      name: "OPERA",
      value: config.browser === "opera",
      type: `boolean`
    },
    {
      name: "COMMAND",
      value: config.command,
      type: `"build" | "serve"`
    }
  ];
}
function getEntrypointGlobals(entrypointName) {
  return [
    {
      name: "ENTRYPOINT",
      value: entrypointName,
      type: `string`
    }
  ];
}

// src/core/builders/vite/plugins/globals.ts
function globals(config) {
  return {
    name: "wxt:globals",
    config() {
      const define = {};
      for (const global of getGlobals(config)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/webextensionPolyfillMock.ts
var import_node_path6 = __toESM(require("path"), 1);
function webextensionPolyfillMock(config) {
  return {
    name: "wxt:testing-inline-deps",
    config() {
      return {
        resolve: {
          alias: {
            // Alias to use a mocked version of the polyfill
            "webextension-polyfill": import_node_path6.default.resolve(
              config.root,
              "node_modules/wxt/dist/virtual/mock-browser"
            )
          }
        },
        ssr: {
          // Inline all WXT modules
          noExternal: ["wxt"]
        }
      };
    }
  };
}

// src/core/builders/vite/plugins/excludeBrowserPolyfill.ts
function excludeBrowserPolyfill(config) {
  const virtualId = "virtual:wxt-webextension-polyfill-disabled";
  return {
    name: "wxt:exclude-browser-polyfill",
    config() {
      if (config.experimental.includeBrowserPolyfill)
        return;
      return {
        resolve: {
          alias: {
            "webextension-polyfill": virtualId
          }
        }
      };
    },
    load(id) {
      if (id === virtualId) {
        return "export default chrome";
      }
    }
  };
}

// src/core/builders/vite/plugins/entrypointGroupGlobals.ts
function entrypointGroupGlobals(entrypointGroup) {
  return {
    name: "wxt:entrypoint-group-globals",
    config() {
      const define = {};
      let name = Array.isArray(entrypointGroup) ? "html" : entrypointGroup.name;
      for (const global of getEntrypointGlobals(name)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/defineImportMeta.ts
function defineImportMeta() {
  return {
    name: "wxt:define",
    config() {
      return {
        define: {
          // This works for all extension contexts, including background service worker
          "import.meta.url": "self.location.href"
        }
      };
    }
  };
}

// src/core/utils/fs.ts
var import_fs_extra3 = __toESM(require("fs-extra"), 1);
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/core/wxt.ts
var import_hookable = require("hookable");

// src/core/utils/fs.ts
async function writeFileIfDifferent(file, newContents) {
  const existingContents = await import_fs_extra3.default.readFile(file, "utf-8").catch(() => void 0);
  if (existingContents !== newContents) {
    await import_fs_extra3.default.writeFile(file, newContents);
  }
}

// src/core/utils/building/build-entrypoints.ts
var import_fs_extra4 = __toESM(require("fs-extra"), 1);
var import_picocolors = __toESM(require("picocolors"), 1);

// src/core/utils/building/find-entrypoints.ts
var import_fs_extra5 = __toESM(require("fs-extra"), 1);
var import_minimatch = require("minimatch");
var import_linkedom2 = require("linkedom");
var import_json5 = __toESM(require("json5"), 1);
var import_fast_glob2 = __toESM(require("fast-glob"), 1);
var import_picocolors2 = __toESM(require("picocolors"), 1);
var PATH_GLOB_TO_TYPE_MAP = {
  "sandbox.html": "sandbox",
  "sandbox/index.html": "sandbox",
  "*.sandbox.html": "sandbox",
  "*.sandbox/index.html": "sandbox",
  "bookmarks.html": "bookmarks",
  "bookmarks/index.html": "bookmarks",
  "history.html": "history",
  "history/index.html": "history",
  "newtab.html": "newtab",
  "newtab/index.html": "newtab",
  "sidepanel.html": "sidepanel",
  "sidepanel/index.html": "sidepanel",
  "*.sidepanel.html": "sidepanel",
  "*.sidepanel/index.html": "sidepanel",
  "devtools.html": "devtools",
  "devtools/index.html": "devtools",
  "background.[jt]s": "background",
  "background/index.[jt]s": "background",
  [VIRTUAL_NOOP_BACKGROUND_MODULE_ID]: "background",
  "content.[jt]s?(x)": "content-script",
  "content/index.[jt]s?(x)": "content-script",
  "*.content.[jt]s?(x)": "content-script",
  "*.content/index.[jt]s?(x)": "content-script",
  [`content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  "popup.html": "popup",
  "popup/index.html": "popup",
  "options.html": "options",
  "options/index.html": "options",
  "*.html": "unlisted-page",
  "*/index.html": "unlisted-page",
  "*.[jt]s?(x)": "unlisted-script",
  "*/index.[jt]s?(x)": "unlisted-script",
  [`*.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style",
  [`*/index.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style"
};

// src/core/utils/building/generate-wxt-dir.ts
var import_unimport2 = require("unimport");
var import_fs_extra6 = __toESM(require("fs-extra"), 1);
var import_node_path7 = __toESM(require("path"), 1);

// src/core/utils/building/resolve-config.ts
var import_c12 = require("c12");
var import_node_path9 = __toESM(require("path"), 1);

// src/core/utils/cache.ts
var import_fs_extra7 = __toESM(require("fs-extra"), 1);
var import_path3 = require("path");
function createFsCache(wxtDir) {
  const getPath = (key) => (0, import_path3.resolve)(wxtDir, "cache", encodeURIComponent(key));
  return {
    async set(key, value) {
      const path7 = getPath(key);
      await (0, import_fs_extra7.ensureDir)((0, import_path3.dirname)(path7));
      await writeFileIfDifferent(path7, value);
    },
    async get(key) {
      const path7 = getPath(key);
      try {
        return await import_fs_extra7.default.readFile(path7, "utf-8");
      } catch {
        return void 0;
      }
    }
  };
}

// src/core/utils/building/resolve-config.ts
var import_consola = __toESM(require("consola"), 1);

// src/core/builders/vite/index.ts
async function createViteBuilder(inlineConfig, userConfig, wxtConfig) {
  const vite = await import("vite");
  const getBaseConfig = async () => {
    const resolvedInlineConfig = await inlineConfig.vite?.(wxtConfig.env) ?? {};
    const resolvedUserConfig = await userConfig.vite?.(wxtConfig.env) ?? {};
    const config = vite.mergeConfig(
      resolvedUserConfig,
      resolvedInlineConfig
    );
    config.root = wxtConfig.root;
    config.configFile = false;
    config.logLevel = "warn";
    config.mode = wxtConfig.mode;
    config.build ??= {};
    config.build.outDir = wxtConfig.outDir;
    config.build.emptyOutDir = false;
    if (config.build.minify == null && wxtConfig.command === "serve") {
      config.build.minify = false;
    }
    if (config.build.sourcemap == null && wxtConfig.command === "serve") {
      config.build.sourcemap = "inline";
    }
    config.plugins ??= [];
    config.plugins.push(
      download(wxtConfig),
      devHtmlPrerender(wxtConfig),
      unimport(wxtConfig),
      virtualEntrypoint("background", wxtConfig),
      virtualEntrypoint("content-script-isolated-world", wxtConfig),
      virtualEntrypoint("content-script-main-world", wxtConfig),
      virtualEntrypoint("unlisted-script", wxtConfig),
      devServerGlobals(wxtConfig),
      tsconfigPaths(wxtConfig),
      noopBackground(),
      globals(wxtConfig),
      excludeBrowserPolyfill(wxtConfig),
      defineImportMeta()
    );
    if (wxtConfig.analysis.enabled) {
      config.plugins.push(bundleAnalysis(wxtConfig));
    }
    return config;
  };
  const getLibModeConfig = (entrypoint) => {
    const entry = getRollupEntry(entrypoint);
    const plugins = [
      entrypointGroupGlobals(entrypoint)
    ];
    if (entrypoint.type === "content-script-style" || entrypoint.type === "unlisted-style") {
      plugins.push(cssEntrypoints(entrypoint, wxtConfig));
    }
    const libMode = {
      mode: wxtConfig.mode,
      plugins,
      build: {
        lib: {
          entry,
          formats: ["iife"],
          name: "_",
          fileName: entrypoint.name
        },
        rollupOptions: {
          output: {
            // There's only a single output for this build, so we use the desired bundle path for the
            // entry output (like "content-scripts/overlay.js")
            entryFileNames: getEntrypointBundlePath(
              entrypoint,
              wxtConfig.outDir,
              ".js"
            ),
            // Output content script CSS to `content-scripts/`, but all other scripts are written to
            // `assets/`.
            assetFileNames: ({ name }) => {
              if (entrypoint.type === "content-script" && name?.endsWith("css")) {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      },
      define: {
        // See https://github.com/aklinker1/vite-plugin-web-extension/issues/96
        "process.env.NODE_ENV": JSON.stringify(wxtConfig.mode)
      }
    };
    return libMode;
  };
  const getMultiPageConfig = (entrypoints) => {
    const htmlEntrypoints = new Set(
      entrypoints.filter(isHtmlEntrypoint).map((e) => e.name)
    );
    return {
      mode: wxtConfig.mode,
      plugins: [
        multipageMove(entrypoints, wxtConfig),
        entrypointGroupGlobals(entrypoints)
      ],
      build: {
        rollupOptions: {
          input: entrypoints.reduce((input, entry) => {
            input[entry.name] = getRollupEntry(entry);
            return input;
          }, {}),
          output: {
            // Include a hash to prevent conflicts
            chunkFileNames: "chunks/[name]-[hash].js",
            entryFileNames: ({ name }) => {
              if (htmlEntrypoints.has(name))
                return "chunks/[name]-[hash].js";
              return "[name].js";
            },
            // We can't control the "name", so we need a hash to prevent conflicts
            assetFileNames: "assets/[name]-[hash].[ext]"
          }
        }
      }
    };
  };
  const getCssConfig = (entrypoint) => {
    return {
      mode: wxtConfig.mode,
      plugins: [entrypointGroupGlobals(entrypoint)],
      build: {
        rollupOptions: {
          input: {
            [entrypoint.name]: entrypoint.inputPath
          },
          output: {
            assetFileNames: () => {
              if (entrypoint.type === "content-script-style") {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      }
    };
  };
  return {
    name: "Vite",
    version: vite.version,
    async build(group) {
      let entryConfig;
      if (Array.isArray(group))
        entryConfig = getMultiPageConfig(group);
      else if (group.inputPath.endsWith(".css"))
        entryConfig = getCssConfig(group);
      else
        entryConfig = getLibModeConfig(group);
      const buildConfig = vite.mergeConfig(await getBaseConfig(), entryConfig);
      const result = await vite.build(buildConfig);
      return {
        entrypoints: group,
        chunks: getBuildOutputChunks(result)
      };
    },
    async createServer(info) {
      const serverConfig = {
        server: {
          port: info.port,
          strictPort: true,
          host: info.hostname,
          origin: info.origin
        }
      };
      const baseConfig = await getBaseConfig();
      const viteServer = await vite.createServer(
        vite.mergeConfig(baseConfig, serverConfig)
      );
      const server = {
        async listen() {
          await viteServer.listen(info.port);
        },
        async close() {
          await viteServer.close();
        },
        transformHtml(...args) {
          return viteServer.transformIndexHtml(...args);
        },
        ws: {
          send(message, payload) {
            return viteServer.ws.send(message, payload);
          },
          on(message, cb) {
            viteServer.ws.on(message, cb);
          }
        },
        watcher: viteServer.watcher
      };
      return server;
    }
  };
}
function getBuildOutputChunks(result) {
  if ("on" in result)
    throw Error("wxt does not support vite watch mode.");
  if (Array.isArray(result))
    return result.flatMap(({ output }) => output);
  return result.output;
}
function getRollupEntry(entrypoint) {
  let virtualEntrypointType;
  switch (entrypoint.type) {
    case "background":
    case "unlisted-script":
      virtualEntrypointType = entrypoint.type;
      break;
    case "content-script":
      virtualEntrypointType = entrypoint.options.world === "MAIN" ? "content-script-main-world" : "content-script-isolated-world";
      break;
  }
  return virtualEntrypointType ? `virtual:wxt-${virtualEntrypointType}?${entrypoint.inputPath}` : entrypoint.inputPath;
}

// src/core/utils/building/resolve-config.ts
var import_defu = __toESM(require("defu"), 1);

// src/core/utils/package.ts
var import_node_path8 = require("path");
var import_fs_extra8 = __toESM(require("fs-extra"), 1);
function isModuleInstalled(name) {
  return import(name).then(() => true).catch(() => false);
}

// src/core/utils/building/resolve-config.ts
async function resolveConfig(inlineConfig, command, server) {
  let userConfig = {};
  let userConfigMetadata;
  if (inlineConfig.configFile !== false) {
    const { config: loadedConfig, ...metadata } = await (0, import_c12.loadConfig)({
      configFile: inlineConfig.configFile,
      name: "wxt",
      cwd: inlineConfig.root ?? process.cwd(),
      rcFile: false,
      jitiOptions: {
        esmResolve: true
      }
    });
    userConfig = loadedConfig ?? {};
    userConfigMetadata = metadata;
  }
  const mergedConfig = mergeInlineConfig(inlineConfig, userConfig);
  const debug = mergedConfig.debug ?? false;
  const logger = mergedConfig.logger ?? import_consola.default;
  if (debug)
    logger.level = import_consola.LogLevels.debug;
  const browser = mergedConfig.browser ?? "chrome";
  const manifestVersion = mergedConfig.manifestVersion ?? (browser === "firefox" || browser === "safari" ? 2 : 3);
  const mode = mergedConfig.mode ?? (command === "build" ? "production" : "development");
  const env = { browser, command, manifestVersion, mode };
  const root = import_node_path9.default.resolve(
    inlineConfig.root ?? userConfig.root ?? process.cwd()
  );
  const wxtDir = import_node_path9.default.resolve(root, ".wxt");
  const srcDir = import_node_path9.default.resolve(root, mergedConfig.srcDir ?? root);
  const entrypointsDir = import_node_path9.default.resolve(
    srcDir,
    mergedConfig.entrypointsDir ?? "entrypoints"
  );
  const filterEntrypoints = !!mergedConfig.filterEntrypoints?.length ? new Set(mergedConfig.filterEntrypoints) : void 0;
  const publicDir = import_node_path9.default.resolve(srcDir, mergedConfig.publicDir ?? "public");
  const typesDir = import_node_path9.default.resolve(wxtDir, "types");
  const outBaseDir = import_node_path9.default.resolve(root, mergedConfig.outDir ?? ".output");
  const outDir = import_node_path9.default.resolve(outBaseDir, `${browser}-mv${manifestVersion}`);
  const reloadCommand = mergedConfig.dev?.reloadCommand ?? "Alt+R";
  const runnerConfig = await (0, import_c12.loadConfig)({
    name: "web-ext",
    cwd: root,
    globalRc: true,
    rcFile: ".webextrc",
    overrides: inlineConfig.runner,
    defaults: userConfig.runner
  });
  const alias = Object.fromEntries(
    Object.entries({
      ...mergedConfig.alias,
      "@": srcDir,
      "~": srcDir,
      "@@": root,
      "~~": root
    }).map(([key, value]) => [key, import_node_path9.default.resolve(root, value)])
  );
  const analysisOutputFile = import_node_path9.default.resolve(
    root,
    mergedConfig.analysis?.outputFile ?? "stats.html"
  );
  const analysisOutputDir = import_node_path9.default.dirname(analysisOutputFile);
  const analysisOutputName = import_node_path9.default.parse(analysisOutputFile).name;
  const finalConfig = {
    browser,
    command,
    debug,
    entrypointsDir,
    filterEntrypoints,
    env,
    fsCache: createFsCache(wxtDir),
    imports: await getUnimportOptions(wxtDir, logger, mergedConfig),
    logger,
    manifest: await resolveManifestConfig(env, mergedConfig.manifest),
    manifestVersion,
    mode,
    outBaseDir,
    outDir,
    publicDir,
    root,
    runnerConfig,
    srcDir,
    typesDir,
    wxtDir,
    zip: resolveInternalZipConfig(root, mergedConfig),
    transformManifest(manifest) {
      userConfig.transformManifest?.(manifest);
      inlineConfig.transformManifest?.(manifest);
    },
    analysis: {
      enabled: mergedConfig.analysis?.enabled ?? false,
      template: mergedConfig.analysis?.template ?? "treemap",
      outputFile: analysisOutputFile,
      outputDir: analysisOutputDir,
      outputName: analysisOutputName,
      keepArtifacts: mergedConfig.analysis?.keepArtifacts ?? false
    },
    userConfigMetadata: userConfigMetadata ?? {},
    alias,
    experimental: {
      includeBrowserPolyfill: mergedConfig.experimental?.includeBrowserPolyfill ?? true
    },
    server,
    dev: {
      reloadCommand
    },
    hooks: mergedConfig.hooks ?? {}
  };
  const builder = await createViteBuilder(
    inlineConfig,
    userConfig,
    finalConfig
  );
  return {
    ...finalConfig,
    builder
  };
}
async function resolveManifestConfig(env, manifest) {
  return await (typeof manifest === "function" ? manifest(env) : manifest ?? {});
}
function mergeInlineConfig(inlineConfig, userConfig) {
  let imports;
  if (inlineConfig.imports === false || userConfig.imports === false) {
    imports = false;
  } else if (userConfig.imports == null && inlineConfig.imports == null) {
    imports = void 0;
  } else {
    imports = (0, import_defu.default)(inlineConfig.imports ?? {}, userConfig.imports ?? {});
  }
  const manifest = async (env) => {
    const user = await resolveManifestConfig(env, userConfig.manifest);
    const inline = await resolveManifestConfig(env, inlineConfig.manifest);
    return (0, import_defu.default)(inline, user);
  };
  const runner = (0, import_defu.default)(
    inlineConfig.runner ?? {},
    userConfig.runner ?? {}
  );
  const zip = (0, import_defu.default)(
    inlineConfig.zip ?? {},
    userConfig.zip ?? {}
  );
  const hooks = (0, import_defu.default)(
    inlineConfig.hooks ?? {},
    userConfig.hooks ?? {}
  );
  return {
    root: inlineConfig.root ?? userConfig.root,
    browser: inlineConfig.browser ?? userConfig.browser,
    manifestVersion: inlineConfig.manifestVersion ?? userConfig.manifestVersion,
    configFile: inlineConfig.configFile,
    debug: inlineConfig.debug ?? userConfig.debug,
    entrypointsDir: inlineConfig.entrypointsDir ?? userConfig.entrypointsDir,
    filterEntrypoints: inlineConfig.filterEntrypoints ?? userConfig.filterEntrypoints,
    imports,
    logger: inlineConfig.logger ?? userConfig.logger,
    manifest,
    mode: inlineConfig.mode ?? userConfig.mode,
    publicDir: inlineConfig.publicDir ?? userConfig.publicDir,
    runner,
    srcDir: inlineConfig.srcDir ?? userConfig.srcDir,
    outDir: inlineConfig.outDir ?? userConfig.outDir,
    zip,
    analysis: {
      ...userConfig.analysis,
      ...inlineConfig.analysis
    },
    alias: {
      ...userConfig.alias,
      ...inlineConfig.alias
    },
    experimental: {
      ...userConfig.experimental,
      ...inlineConfig.experimental
    },
    vite: void 0,
    transformManifest: void 0,
    dev: {
      ...userConfig.dev,
      ...inlineConfig.dev
    },
    hooks
  };
}
function resolveInternalZipConfig(root, mergedConfig) {
  return {
    name: void 0,
    sourcesTemplate: "{{name}}-{{version}}-sources.zip",
    artifactTemplate: "{{name}}-{{version}}-{{browser}}.zip",
    sourcesRoot: root,
    includeSources: [],
    ...mergedConfig.zip,
    excludeSources: [
      "**/node_modules",
      // WXT files
      "**/web-ext.config.ts",
      // Hidden files
      "**/.*",
      // Tests
      "**/__tests__/**",
      "**/*.+(test|spec).?(c|m)+(j|t)s?(x)",
      // From user
      ...mergedConfig.zip?.excludeSources ?? []
    ]
  };
}
async function getUnimportOptions(wxtDir, logger, config) {
  if (config.imports === false)
    return false;
  const enabledConfig = config.imports?.eslintrc?.enabled;
  let enabled;
  switch (enabledConfig) {
    case void 0:
    case "auto":
      enabled = await isModuleInstalled("eslint");
      break;
    default:
      enabled = enabledConfig;
  }
  const defaultOptions = {
    debugLog: logger.debug,
    imports: [
      { name: "defineConfig", from: "wxt" },
      { name: "fakeBrowser", from: "wxt/testing" }
    ],
    presets: [
      { package: "wxt/client" },
      { package: "wxt/browser" },
      { package: "wxt/sandbox" },
      { package: "wxt/storage" }
    ],
    warn: logger.warn,
    dirs: ["components", "composables", "hooks", "utils"],
    eslintrc: {
      enabled,
      filePath: import_node_path9.default.resolve(wxtDir, "eslintrc-auto-import.json"),
      globalsPropValue: true
    }
  };
  return (0, import_defu.default)(
    config.imports ?? {},
    defaultOptions
  );
}

// src/core/utils/building/import-entrypoint.ts
var import_jiti = __toESM(require("jiti"), 1);
var import_unimport3 = require("unimport");
var import_fs_extra9 = __toESM(require("fs-extra"), 1);
var import_node_path10 = require("path");
var import_esbuild = require("esbuild");
var import_node_url = require("url");

// src/core/utils/building/internal-build.ts
var import_picocolors5 = __toESM(require("picocolors"), 1);
var import_fs_extra12 = __toESM(require("fs-extra"), 1);

// src/core/utils/log/printFileList.ts
var import_node_path11 = __toESM(require("path"), 1);
var import_picocolors3 = __toESM(require("picocolors"), 1);
var import_fs_extra10 = __toESM(require("fs-extra"), 1);
var import_filesize = require("filesize");
var DEFAULT_COLOR = import_picocolors3.default.blue;
var CHUNK_COLORS = {
  ".js.map": import_picocolors3.default.gray,
  ".cjs.map": import_picocolors3.default.gray,
  ".mjs.map": import_picocolors3.default.gray,
  ".html": import_picocolors3.default.green,
  ".css": import_picocolors3.default.magenta,
  ".js": import_picocolors3.default.cyan,
  ".cjs": import_picocolors3.default.cyan,
  ".mjs": import_picocolors3.default.cyan,
  ".zip": import_picocolors3.default.yellow
};

// src/core/utils/log/printHeader.ts
var import_picocolors4 = __toESM(require("picocolors"), 1);
var import_consola2 = require("consola");

// src/core/utils/building/internal-build.ts
var import_fast_glob3 = __toESM(require("fast-glob"), 1);

// src/core/utils/manifest.ts
var import_fs_extra11 = __toESM(require("fs-extra"), 1);
var import_defu2 = __toESM(require("defu"), 1);

// src/core/utils/building/internal-build.ts
var import_node_path13 = require("path");
var import_consola3 = __toESM(require("consola"), 1);

// src/core/utils/exec.ts
var import_manage_path = __toESM(require("manage-path"), 1);
var import_node_path12 = require("path");
var managedPath = (0, import_manage_path.default)(process.env);

// src/testing/wxt-vitest-plugin.ts
function WxtVitest(inlineConfig) {
  return resolveConfig(inlineConfig ?? {}, "serve").then((config) => [
    webextensionPolyfillMock(config),
    unimport(config),
    globals(config),
    download(config),
    tsconfigPaths(config)
  ]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WxtVitest,
  fakeBrowser
});
