import { createRequire } from 'module';const require = createRequire(import.meta.url);
import "./chunk-73I7FAJU.js";

// src/cli/commands.ts
import cac from "cac";

// src/core/utils/fs.ts
import fs from "fs-extra";
import glob from "fast-glob";

// src/core/utils/paths.ts
import systemPath from "node:path";
import normalize from "normalize-path";
function normalizePath(path8) {
  return normalize(path8);
}
function unnormalizePath(path8) {
  return systemPath.normalize(path8);
}
var CSS_EXTENSIONS = ["css", "scss", "sass", "less", "styl", "stylus"];
var CSS_EXTENSIONS_PATTERN = `+(${CSS_EXTENSIONS.join("|")})`;

// src/core/wxt.ts
import { createHooks } from "hookable";
var wxt;
async function registerWxt(command, inlineConfig = {}, server) {
  const config = await resolveConfig(inlineConfig, command, server);
  const hooks = createHooks();
  wxt = {
    config,
    hooks,
    get logger() {
      return config.logger;
    },
    async reloadConfig() {
      wxt.config = await resolveConfig(inlineConfig, command, server);
    }
  };
  wxt.hooks.addHooks(config.hooks);
  await wxt.hooks.callHook("ready", wxt);
}

// src/core/utils/fs.ts
async function writeFileIfDifferent(file, newContents) {
  const existingContents = await fs.readFile(file, "utf-8").catch(() => void 0);
  if (existingContents !== newContents) {
    await fs.writeFile(file, newContents);
  }
}
async function getPublicFiles() {
  if (!await fs.exists(wxt.config.publicDir))
    return [];
  const files = await glob("**/*", { cwd: wxt.config.publicDir });
  return files.map(unnormalizePath);
}

// src/core/utils/building/build-entrypoints.ts
import fs2 from "fs-extra";
import { dirname, resolve } from "path";
import pc from "picocolors";
async function buildEntrypoints(groups, spinner) {
  const steps = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    const groupNames = [group].flat().map((e) => e.name);
    const groupNameColored = groupNames.join(pc.dim(", "));
    spinner.text = pc.dim(`[${i + 1}/${groups.length}]`) + ` ${groupNameColored}`;
    try {
      steps.push(await wxt.config.builder.build(group));
    } catch (err) {
      wxt.logger.error(err);
      throw Error(`Failed to build ${groupNames.join(", ")}`, { cause: err });
    }
  }
  const publicAssets = await copyPublicDirectory();
  return { publicAssets, steps };
}
async function copyPublicDirectory() {
  const files = await getPublicFiles();
  if (files.length === 0)
    return [];
  const publicAssets = [];
  for (const file of files) {
    const srcPath = resolve(wxt.config.publicDir, file);
    const outPath = resolve(wxt.config.outDir, file);
    await fs2.ensureDir(dirname(outPath));
    await fs2.copyFile(srcPath, outPath);
    publicAssets.push({
      type: "asset",
      fileName: file
    });
  }
  return publicAssets;
}

// src/core/utils/arrays.ts
function every(array, predicate) {
  for (let i = 0; i < array.length; i++)
    if (!predicate(array[i], i))
      return false;
  return true;
}
function some(array, predicate) {
  for (let i = 0; i < array.length; i++)
    if (predicate(array[i], i))
      return true;
  return false;
}

// src/core/utils/building/detect-dev-changes.ts
function detectDevChanges(changedFiles, currentOutput) {
  const isConfigChange = some(
    changedFiles,
    (file) => file === wxt.config.userConfigMetadata.configFile
  );
  if (isConfigChange)
    return { type: "full-restart" };
  const isRunnerChange = some(
    changedFiles,
    (file) => file === wxt.config.runnerConfig.configFile
  );
  if (isRunnerChange)
    return { type: "browser-restart" };
  const changedSteps = new Set(
    changedFiles.flatMap(
      (changedFile) => findEffectedSteps(changedFile, currentOutput)
    )
  );
  if (changedSteps.size === 0)
    return { type: "no-change" };
  const unchangedOutput = {
    manifest: currentOutput.manifest,
    steps: [],
    publicAssets: []
  };
  const changedOutput = {
    manifest: currentOutput.manifest,
    steps: [],
    publicAssets: []
  };
  for (const step of currentOutput.steps) {
    if (changedSteps.has(step)) {
      changedOutput.steps.push(step);
    } else {
      unchangedOutput.steps.push(step);
    }
  }
  for (const asset of currentOutput.publicAssets) {
    if (changedSteps.has(asset)) {
      changedOutput.publicAssets.push(asset);
    } else {
      unchangedOutput.publicAssets.push(asset);
    }
  }
  const isOnlyHtmlChanges = changedFiles.length > 0 && every(changedFiles, (file) => file.endsWith(".html"));
  if (isOnlyHtmlChanges) {
    return {
      type: "html-reload",
      cachedOutput: unchangedOutput,
      rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
    };
  }
  const isOnlyContentScripts = changedOutput.steps.length > 0 && every(
    changedOutput.steps.flatMap((step) => step.entrypoints),
    (entry) => entry.type === "content-script"
  );
  if (isOnlyContentScripts) {
    return {
      type: "content-script-reload",
      cachedOutput: unchangedOutput,
      changedSteps: changedOutput.steps,
      rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
    };
  }
  return {
    type: "extension-reload",
    cachedOutput: unchangedOutput,
    rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
  };
}
function findEffectedSteps(changedFile, currentOutput) {
  const changes = [];
  const changedPath = normalizePath(changedFile);
  const isChunkEffected = (chunk) => (
    // If it's an HTML file with the same path, is is effected because HTML files need to be re-rendered
    // - fileName is normalized, relative bundle path, "<entrypoint-name>.html"
    chunk.type === "asset" && changedPath.replace("/index.html", ".html").endsWith(chunk.fileName) || // If it's a chunk that depends on the changed file, it is effected
    // - moduleIds are absolute, normalized paths
    chunk.type === "chunk" && chunk.moduleIds.includes(changedPath)
  );
  for (const step of currentOutput.steps) {
    const effectedChunk = step.chunks.find((chunk) => isChunkEffected(chunk));
    if (effectedChunk)
      changes.push(step);
  }
  const effectedAsset = currentOutput.publicAssets.find(
    (chunk) => isChunkEffected(chunk)
  );
  if (effectedAsset)
    changes.push(effectedAsset);
  return changes;
}

// src/core/utils/building/find-entrypoints.ts
import { relative as relative2, resolve as resolve3 } from "path";
import fs3 from "fs-extra";
import { minimatch } from "minimatch";
import { parseHTML } from "linkedom";
import JSON5 from "json5";
import glob2 from "fast-glob";

// src/core/utils/entrypoints.ts
import path, { relative, resolve as resolve2 } from "node:path";
function getEntrypointName(entrypointsDir, inputPath) {
  const relativePath = path.relative(entrypointsDir, inputPath);
  const name = relativePath.split(/[\.\/\\]/, 2)[0];
  return name;
}
function getEntrypointOutputFile(entrypoint, ext) {
  return resolve2(entrypoint.outputDir, `${entrypoint.name}${ext}`);
}
function getEntrypointBundlePath(entrypoint, outDir, ext) {
  return normalizePath(
    relative(outDir, getEntrypointOutputFile(entrypoint, ext))
  );
}
function resolvePerBrowserOption(option, browser) {
  if (typeof option === "object" && !Array.isArray(option))
    return option[browser];
  return option;
}
function resolvePerBrowserOptions(options, browser) {
  return Object.fromEntries(
    Object.entries(options).map(([key, value]) => [
      key,
      key === "defaultIcon" ? value : resolvePerBrowserOption(value, browser)
    ])
  );
}
function isHtmlEntrypoint(entrypoint) {
  return entrypoint.inputPath.endsWith(".html");
}

// src/core/utils/constants.ts
var VIRTUAL_NOOP_BACKGROUND_MODULE_ID = "virtual:user-background";

// src/core/utils/building/find-entrypoints.ts
import pc2 from "picocolors";
async function findEntrypoints() {
  const relativePaths = await glob2(Object.keys(PATH_GLOB_TO_TYPE_MAP), {
    cwd: wxt.config.entrypointsDir
  });
  relativePaths.sort();
  const pathGlobs = Object.keys(PATH_GLOB_TO_TYPE_MAP);
  const entrypointInfos = relativePaths.reduce((results, relativePath) => {
    const inputPath = resolve3(wxt.config.entrypointsDir, relativePath);
    const name = getEntrypointName(wxt.config.entrypointsDir, inputPath);
    const matchingGlob = pathGlobs.find(
      (glob5) => minimatch(relativePath, glob5)
    );
    if (matchingGlob) {
      const type = PATH_GLOB_TO_TYPE_MAP[matchingGlob];
      results.push({
        name,
        inputPath,
        type,
        skipped: wxt.config.filterEntrypoints != null && !wxt.config.filterEntrypoints.has(name)
      });
    }
    return results;
  }, []);
  preventNoEntrypoints(entrypointInfos);
  preventDuplicateEntrypointNames(entrypointInfos);
  let hasBackground = false;
  const entrypoints = await Promise.all(
    entrypointInfos.map(async (info) => {
      const { type } = info;
      switch (type) {
        case "popup":
          return await getPopupEntrypoint(info);
        case "sidepanel":
          return await getSidepanelEntrypoint(info);
        case "options":
          return await getOptionsEntrypoint(info);
        case "background":
          hasBackground = true;
          return await getBackgroundEntrypoint(info);
        case "content-script":
          return await getContentScriptEntrypoint(info);
        case "unlisted-page":
          return await getUnlistedPageEntrypoint(info);
        case "unlisted-script":
          return await getUnlistedScriptEntrypoint(info);
        case "content-script-style":
          return {
            ...info,
            type,
            outputDir: resolve3(wxt.config.outDir, CONTENT_SCRIPT_OUT_DIR),
            options: {
              include: void 0,
              exclude: void 0
            }
          };
        default:
          return {
            ...info,
            type,
            outputDir: wxt.config.outDir,
            options: {
              include: void 0,
              exclude: void 0
            }
          };
      }
    })
  );
  if (wxt.config.command === "serve" && !hasBackground) {
    entrypoints.push(
      await getBackgroundEntrypoint({
        inputPath: VIRTUAL_NOOP_BACKGROUND_MODULE_ID,
        name: "background",
        type: "background",
        skipped: false
      })
    );
  }
  wxt.logger.debug("All entrypoints:", entrypoints);
  const skippedEntrypointNames = entrypointInfos.filter((item) => item.skipped).map((item) => item.name);
  if (skippedEntrypointNames.length) {
    wxt.logger.warn(
      `Filter excluded the following entrypoints:
${skippedEntrypointNames.map((item) => `${pc2.dim("-")} ${pc2.cyan(item)}`).join("\n")}`
    );
  }
  const targetEntrypoints = entrypoints.filter((entry) => {
    const { include, exclude } = entry.options;
    if (include?.length && exclude?.length) {
      wxt.logger.warn(
        `The ${entry.name} entrypoint lists both include and exclude, but only one can be used per entrypoint. Entrypoint ignored.`
      );
      return false;
    }
    if (exclude?.length && !include?.length) {
      return !exclude.includes(wxt.config.browser);
    }
    if (include?.length && !exclude?.length) {
      return include.includes(wxt.config.browser);
    }
    if (skippedEntrypointNames.includes(entry.name)) {
      return false;
    }
    return true;
  });
  wxt.logger.debug(`${wxt.config.browser} entrypoints:`, targetEntrypoints);
  await wxt.hooks.callHook("entrypoints:resolved", wxt, targetEntrypoints);
  return targetEntrypoints;
}
function preventDuplicateEntrypointNames(files) {
  const namesToPaths = files.reduce(
    (map, { name, inputPath }) => {
      map[name] ??= [];
      map[name].push(inputPath);
      return map;
    },
    {}
  );
  const errorLines = Object.entries(namesToPaths).reduce(
    (lines, [name, absolutePaths]) => {
      if (absolutePaths.length > 1) {
        lines.push(`- ${name}`);
        absolutePaths.forEach((absolutePath) => {
          lines.push(`  - ${relative2(wxt.config.root, absolutePath)}`);
        });
      }
      return lines;
    },
    []
  );
  if (errorLines.length > 0) {
    const errorContent = errorLines.join("\n");
    throw Error(
      `Multiple entrypoints with the same name detected, only one entrypoint for each name is allowed.

${errorContent}`
    );
  }
}
function preventNoEntrypoints(files) {
  if (files.length === 0) {
    throw Error(`No entrypoints found in ${wxt.config.entrypointsDir}`);
  }
}
async function getPopupEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      exclude: "exclude",
      include: "include",
      defaultIcon: "default_icon",
      defaultTitle: "default_title",
      mv2Key: "type"
    },
    {
      defaultTitle: (document) => document.querySelector("title")?.textContent || void 0
    },
    {
      defaultTitle: (content) => content,
      mv2Key: (content) => content === "page_action" ? "page_action" : "browser_action"
    }
  );
  return {
    type: "popup",
    name: "popup",
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getOptionsEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      chromeStyle: "chrome_style",
      exclude: "exclude",
      include: "include",
      openInTab: "open_in_tab"
    }
  );
  return {
    type: "options",
    name: "options",
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getUnlistedPageEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(info, {
    exclude: "exclude",
    include: "include"
  });
  return {
    type: "unlisted-page",
    name: info.name,
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    options,
    skipped: info.skipped
  };
}
async function getUnlistedScriptEntrypoint({
  inputPath,
  name,
  skipped
}) {
  const defaultExport = await importEntrypointFile(inputPath);
  if (defaultExport == null) {
    throw Error(
      `${name}: Default export not found, did you forget to call "export default defineUnlistedScript(...)"?`
    );
  }
  const { main: _, ...options } = defaultExport;
  return {
    type: "unlisted-script",
    name,
    inputPath,
    outputDir: wxt.config.outDir,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getBackgroundEntrypoint({
  inputPath,
  name,
  skipped
}) {
  let options = {};
  if (inputPath !== VIRTUAL_NOOP_BACKGROUND_MODULE_ID) {
    const defaultExport = await importEntrypointFile(inputPath);
    if (defaultExport == null) {
      throw Error(
        `${name}: Default export not found, did you forget to call "export default defineBackground(...)"?`
      );
    }
    const { main: _, ...moduleOptions } = defaultExport;
    options = moduleOptions;
  }
  if (wxt.config.manifestVersion !== 3) {
    delete options.type;
  }
  return {
    type: "background",
    name,
    inputPath,
    outputDir: wxt.config.outDir,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getContentScriptEntrypoint({
  inputPath,
  name,
  skipped
}) {
  const { main: _, ...options } = await importEntrypointFile(inputPath);
  if (options == null) {
    throw Error(
      `${name}: Default export not found, did you forget to call "export default defineContentScript(...)"?`
    );
  }
  return {
    type: "content-script",
    name,
    inputPath,
    outputDir: resolve3(wxt.config.outDir, CONTENT_SCRIPT_OUT_DIR),
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getSidepanelEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      exclude: "exclude",
      include: "include",
      defaultIcon: "default_icon",
      defaultTitle: "default_title",
      openAtInstall: "open_at_install"
    },
    {
      defaultTitle: (document) => document.querySelector("title")?.textContent || void 0
    },
    {
      defaultTitle: (content) => content
    }
  );
  return {
    type: "sidepanel",
    name: info.name,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getHtmlEntrypointOptions(info, keyMap, queries, parsers) {
  const content = await fs3.readFile(info.inputPath, "utf-8");
  const { document } = parseHTML(content);
  const options = {};
  const defaultQuery = (manifestKey) => document.querySelector(`meta[name='manifest.${manifestKey}']`)?.getAttribute("content");
  Object.entries(keyMap).forEach(([_key, manifestKey]) => {
    const key = _key;
    const content2 = queries?.[key] ? queries[key](document, manifestKey) : defaultQuery(manifestKey);
    if (content2) {
      try {
        options[key] = (parsers?.[key] ?? JSON5.parse)(content2);
      } catch (err) {
        wxt.logger.fatal(
          `Failed to parse meta tag content. Usually this means you have invalid JSON5 content (content=${content2})`,
          err
        );
      }
    }
  });
  return options;
}
var PATH_GLOB_TO_TYPE_MAP = {
  "sandbox.html": "sandbox",
  "sandbox/index.html": "sandbox",
  "*.sandbox.html": "sandbox",
  "*.sandbox/index.html": "sandbox",
  "bookmarks.html": "bookmarks",
  "bookmarks/index.html": "bookmarks",
  "history.html": "history",
  "history/index.html": "history",
  "newtab.html": "newtab",
  "newtab/index.html": "newtab",
  "sidepanel.html": "sidepanel",
  "sidepanel/index.html": "sidepanel",
  "*.sidepanel.html": "sidepanel",
  "*.sidepanel/index.html": "sidepanel",
  "devtools.html": "devtools",
  "devtools/index.html": "devtools",
  "background.[jt]s": "background",
  "background/index.[jt]s": "background",
  [VIRTUAL_NOOP_BACKGROUND_MODULE_ID]: "background",
  "content.[jt]s?(x)": "content-script",
  "content/index.[jt]s?(x)": "content-script",
  "*.content.[jt]s?(x)": "content-script",
  "*.content/index.[jt]s?(x)": "content-script",
  [`content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  "popup.html": "popup",
  "popup/index.html": "popup",
  "options.html": "options",
  "options/index.html": "options",
  "*.html": "unlisted-page",
  "*/index.html": "unlisted-page",
  "*.[jt]s?(x)": "unlisted-script",
  "*/index.[jt]s?(x)": "unlisted-script",
  [`*.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style",
  [`*/index.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style"
};
var CONTENT_SCRIPT_OUT_DIR = "content-scripts";

// src/core/utils/building/generate-wxt-dir.ts
import { createUnimport } from "unimport";
import fs4 from "fs-extra";
import { relative as relative3, resolve as resolve4 } from "path";

// src/core/utils/globals.ts
function getGlobals(config) {
  return [
    {
      name: "MANIFEST_VERSION",
      value: config.manifestVersion,
      type: `2 | 3`
    },
    {
      name: "BROWSER",
      value: config.browser,
      type: `string`
    },
    {
      name: "CHROME",
      value: config.browser === "chrome",
      type: `boolean`
    },
    {
      name: "FIREFOX",
      value: config.browser === "firefox",
      type: `boolean`
    },
    {
      name: "SAFARI",
      value: config.browser === "safari",
      type: `boolean`
    },
    {
      name: "EDGE",
      value: config.browser === "edge",
      type: `boolean`
    },
    {
      name: "OPERA",
      value: config.browser === "opera",
      type: `boolean`
    },
    {
      name: "COMMAND",
      value: config.command,
      type: `"build" | "serve"`
    }
  ];
}
function getEntrypointGlobals(entrypointName) {
  return [
    {
      name: "ENTRYPOINT",
      value: entrypointName,
      type: `string`
    }
  ];
}

// src/core/utils/building/generate-wxt-dir.ts
import path2 from "node:path";

// src/core/utils/i18n.ts
var predefinedMessages = {
  "@@extension_id": {
    message: "<browser.runtime.id>",
    description: "The extension or app ID; you might use this string to construct URLs for resources inside the extension. Even unlocalized extensions can use this message.\nNote: You can't use this message in a manifest file."
  },
  "@@ui_locale": {
    message: "<browser.i18n.getUiLocale()>",
    description: ""
  },
  "@@bidi_dir": {
    message: "<ltr|rtl>",
    description: 'The text direction for the current locale, either "ltr" for left-to-right languages such as English or "rtl" for right-to-left languages such as Japanese.'
  },
  "@@bidi_reversed_dir": {
    message: "<rtl|ltr>",
    description: `If the @@bidi_dir is "ltr", then this is "rtl"; otherwise, it's "ltr".`
  },
  "@@bidi_start_edge": {
    message: "<left|right>",
    description: `If the @@bidi_dir is "ltr", then this is "left"; otherwise, it's "right".`
  },
  "@@bidi_end_edge": {
    message: "<right|left>",
    description: `If the @@bidi_dir is "ltr", then this is "right"; otherwise, it's "left".`
  }
};
function parseI18nMessages(messagesJson) {
  return Object.entries({
    ...predefinedMessages,
    ...messagesJson
  }).map(([name, details]) => ({
    name,
    ...details
  }));
}

// src/core/utils/building/generate-wxt-dir.ts
async function generateTypesDir(entrypoints) {
  await fs4.ensureDir(wxt.config.typesDir);
  const references = [];
  if (wxt.config.imports !== false) {
    const unimport2 = createUnimport(wxt.config.imports);
    references.push(await writeImportsDeclarationFile(unimport2));
    if (wxt.config.imports.eslintrc.enabled) {
      await writeImportsEslintFile(unimport2, wxt.config.imports);
    }
  }
  references.push(await writePathsDeclarationFile(entrypoints));
  references.push(await writeI18nDeclarationFile());
  references.push(await writeGlobalsDeclarationFile());
  const mainReference = await writeMainDeclarationFile(references);
  await writeTsConfigFile(mainReference);
}
async function writeImportsDeclarationFile(unimport2) {
  const filePath = resolve4(wxt.config.typesDir, "imports.d.ts");
  await unimport2.scanImportsFromDir(void 0, { cwd: wxt.config.srcDir });
  await writeFileIfDifferent(
    filePath,
    ["// Generated by wxt", await unimport2.generateTypeDeclarations()].join(
      "\n"
    ) + "\n"
  );
  return filePath;
}
async function writeImportsEslintFile(unimport2, options) {
  const globals2 = {};
  const eslintrc = { globals: globals2 };
  (await unimport2.getImports()).map((i) => i.as ?? i.name).filter(Boolean).sort().forEach((name) => {
    eslintrc.globals[name] = options.eslintrc.globalsPropValue;
  });
  await fs4.writeJson(options.eslintrc.filePath, eslintrc, { spaces: 2 });
}
async function writePathsDeclarationFile(entrypoints) {
  const filePath = resolve4(wxt.config.typesDir, "paths.d.ts");
  const unions = entrypoints.map(
    (entry) => getEntrypointBundlePath(
      entry,
      wxt.config.outDir,
      isHtmlEntrypoint(entry) ? ".html" : ".js"
    )
  ).concat(await getPublicFiles()).map(normalizePath).map((path8) => `    | "/${path8}"`).sort().join("\n");
  const template = `// Generated by wxt
import "wxt/browser";

declare module "wxt/browser" {
  export type PublicPath =
{{ union }}
  type HtmlPublicPath = Extract<PublicPath, \`\${string}.html\`>
  export interface WxtRuntime extends Runtime.Static {
    getURL(path: PublicPath): string;
    getURL(path: \`\${HtmlPublicPath}\${string}\`): string;
  }
}
`;
  await writeFileIfDifferent(
    filePath,
    template.replace("{{ union }}", unions || "    | never")
  );
  return filePath;
}
async function writeI18nDeclarationFile() {
  const filePath = resolve4(wxt.config.typesDir, "i18n.d.ts");
  const defaultLocale = wxt.config.manifest.default_locale;
  const template = `// Generated by wxt
import "wxt/browser";

declare module "wxt/browser" {
  /**
   * See https://developer.chrome.com/docs/extensions/reference/i18n/#method-getMessage
   */
  interface GetMessageOptions {
    /**
     * See https://developer.chrome.com/docs/extensions/reference/i18n/#method-getMessage
     */
    escapeLt?: boolean
  }

  export interface WxtI18n extends I18n.Static {
{{ overrides }}
  }
}
`;
  let messages;
  if (defaultLocale) {
    const defaultLocalePath = path2.resolve(
      wxt.config.publicDir,
      "_locales",
      defaultLocale,
      "messages.json"
    );
    const content = JSON.parse(await fs4.readFile(defaultLocalePath, "utf-8"));
    messages = parseI18nMessages(content);
  } else {
    messages = parseI18nMessages({});
  }
  const overrides = messages.map((message) => {
    return `    /**
     * ${message.description || "No message description."}
     *
     * "${message.message}"
     */
    getMessage(
      messageName: "${message.name}",
      substitutions?: string | string[],
      options?: GetMessageOptions,
    ): string;`;
  });
  await writeFileIfDifferent(
    filePath,
    template.replace("{{ overrides }}", overrides.join("\n"))
  );
  return filePath;
}
async function writeGlobalsDeclarationFile() {
  const filePath = resolve4(wxt.config.typesDir, "globals.d.ts");
  const globals2 = [...getGlobals(wxt.config), ...getEntrypointGlobals("")];
  await writeFileIfDifferent(
    filePath,
    [
      "// Generated by wxt",
      "export {}",
      "interface ImportMetaEnv {",
      ...globals2.map((global) => `  readonly ${global.name}: ${global.type};`),
      "}",
      "interface ImportMeta {",
      "  readonly env: ImportMetaEnv",
      "}"
    ].join("\n") + "\n"
  );
  return filePath;
}
async function writeMainDeclarationFile(references) {
  const dir = wxt.config.wxtDir;
  const filePath = resolve4(dir, "wxt.d.ts");
  await writeFileIfDifferent(
    filePath,
    [
      "// Generated by wxt",
      `/// <reference types="wxt/vite-builder-env" />`,
      ...references.map(
        (ref) => `/// <reference types="./${normalizePath(relative3(dir, ref))}" />`
      )
    ].join("\n") + "\n"
  );
  return filePath;
}
async function writeTsConfigFile(mainReference) {
  const dir = wxt.config.wxtDir;
  const getTsconfigPath = (path8) => normalizePath(relative3(dir, path8));
  const paths = Object.entries(wxt.config.alias).flatMap(([alias, absolutePath]) => {
    const aliasPath = getTsconfigPath(absolutePath);
    return [
      `      "${alias}": ["${aliasPath}"]`,
      `      "${alias}/*": ["${aliasPath}/*"]`
    ];
  }).join(",\n");
  await writeFileIfDifferent(
    resolve4(dir, "tsconfig.json"),
    `{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "noEmit": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "strict": true,
    "skipLibCheck": true,
    "paths": {
${paths}
    }
  },
  "include": [
    "${getTsconfigPath(wxt.config.root)}/**/*",
    "./${getTsconfigPath(mainReference)}"
  ],
  "exclude": ["${getTsconfigPath(wxt.config.outBaseDir)}"]
}`
  );
}

// src/core/utils/building/resolve-config.ts
import { loadConfig } from "c12";
import path4 from "node:path";

// src/core/utils/cache.ts
import fs5, { ensureDir } from "fs-extra";
import { dirname as dirname2, resolve as resolve5 } from "path";
function createFsCache(wxtDir) {
  const getPath = (key) => resolve5(wxtDir, "cache", encodeURIComponent(key));
  return {
    async set(key, value) {
      const path8 = getPath(key);
      await ensureDir(dirname2(path8));
      await writeFileIfDifferent(path8, value);
    },
    async get(key) {
      const path8 = getPath(key);
      try {
        return await fs5.readFile(path8, "utf-8");
      } catch {
        return void 0;
      }
    }
  };
}

// src/core/utils/building/resolve-config.ts
import consola, { LogLevels } from "consola";

// src/core/builders/vite/plugins/devHtmlPrerender.ts
import { parseHTML as parseHTML2 } from "linkedom";
import { dirname as dirname3, relative as relative4, resolve as resolve6 } from "node:path";
var reactRefreshPreamble = "";
function devHtmlPrerender(config) {
  const htmlReloadId = "@wxt/reload-html";
  const resolvedHtmlReloadId = resolve6(
    config.root,
    "node_modules/wxt/dist/virtual/reload-html.js"
  );
  const virtualReactRefreshId = "@wxt/virtual-react-refresh";
  const resolvedVirtualReactRefreshId = "\0" + virtualReactRefreshId;
  return [
    {
      apply: "build",
      name: "wxt:dev-html-prerender",
      config() {
        return {
          resolve: {
            alias: {
              [htmlReloadId]: resolvedHtmlReloadId
            }
          }
        };
      },
      // Convert scripts like src="./main.tsx" -> src="http://localhost:3000/entrypoints/popup/main.tsx"
      // before the paths are replaced with their bundled path
      transform(code, id) {
        const server = config.server;
        if (config.command !== "serve" || server == null || !id.endsWith(".html"))
          return;
        const { document } = parseHTML2(code);
        const _pointToDevServer = (querySelector, attr) => pointToDevServer(config, server, id, document, querySelector, attr);
        _pointToDevServer("script[type=module]", "src");
        _pointToDevServer("link[rel=stylesheet]", "href");
        const reloader = document.createElement("script");
        reloader.src = htmlReloadId;
        reloader.type = "module";
        document.head.appendChild(reloader);
        const newHtml = document.toString();
        config.logger.debug("transform " + id);
        config.logger.debug("Old HTML:\n" + code);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      },
      // Pass the HTML through the dev server to add dev-mode specific code
      async transformIndexHtml(html, ctx) {
        const server = config.server;
        if (config.command !== "serve" || server == null)
          return;
        const originalUrl = `${server.origin}${ctx.path}`;
        const name = getEntrypointName(config.entrypointsDir, ctx.filename);
        const url = `${server.origin}/${name}.html`;
        const serverHtml = await server.transformHtml(url, html, originalUrl);
        const { document } = parseHTML2(serverHtml);
        const reactRefreshScript = Array.from(
          document.querySelectorAll("script[type=module]")
        ).find((script) => script.innerHTML.includes("@react-refresh"));
        if (reactRefreshScript) {
          reactRefreshPreamble = reactRefreshScript.innerHTML;
          const virtualScript = document.createElement("script");
          virtualScript.type = "module";
          virtualScript.src = `${server.origin}/${virtualReactRefreshId}`;
          reactRefreshScript.replaceWith(virtualScript);
        }
        const viteClientScript = document.querySelector(
          "script[src='/@vite/client']"
        );
        if (viteClientScript) {
          viteClientScript.src = `${server.origin}${viteClientScript.src}`;
        }
        const newHtml = document.toString();
        config.logger.debug("transformIndexHtml " + ctx.filename);
        config.logger.debug("Old HTML:\n" + html);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      }
    },
    {
      name: "wxt:virtualize-react-refresh",
      apply: "serve",
      resolveId(id) {
        if (id === `/${virtualReactRefreshId}`) {
          return resolvedVirtualReactRefreshId;
        }
        if (id.startsWith("/chunks/")) {
          return "\0noop";
        }
      },
      load(id) {
        if (id === resolvedVirtualReactRefreshId) {
          return reactRefreshPreamble;
        }
        if (id === "\0noop") {
          return "";
        }
      }
    }
  ];
}
function pointToDevServer(config, server, id, document, querySelector, attr) {
  document.querySelectorAll(querySelector).forEach((element) => {
    const src = element.getAttribute(attr);
    if (!src || isUrl(src))
      return;
    let resolvedAbsolutePath;
    const matchingAlias = Object.entries(config.alias).find(
      ([key]) => src.startsWith(key)
    );
    if (matchingAlias) {
      const [alias, replacement] = matchingAlias;
      resolvedAbsolutePath = resolve6(
        config.root,
        src.replace(alias, replacement)
      );
    } else {
      resolvedAbsolutePath = resolve6(dirname3(id), src);
    }
    if (resolvedAbsolutePath) {
      const relativePath = normalizePath(
        relative4(config.root, resolvedAbsolutePath)
      );
      if (relativePath.startsWith(".")) {
        let path8 = normalizePath(resolvedAbsolutePath);
        if (!path8.startsWith("/"))
          path8 = "/" + path8;
        element.setAttribute(attr, `${server.origin}/@fs${path8}`);
      } else {
        const url = new URL(relativePath, server.origin);
        element.setAttribute(attr, url.href);
      }
    }
  });
}
function isUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}

// src/core/builders/vite/plugins/devServerGlobals.ts
function devServerGlobals(config) {
  return {
    name: "wxt:dev-server-globals",
    config() {
      if (config.server == null || config.command == "build")
        return;
      return {
        define: {
          __DEV_SERVER_PROTOCOL__: JSON.stringify("ws:"),
          __DEV_SERVER_HOSTNAME__: JSON.stringify(config.server.hostname),
          __DEV_SERVER_PORT__: JSON.stringify(config.server.port)
        }
      };
    }
  };
}

// src/core/utils/network.ts
import dns from "node:dns";

// src/core/utils/time.ts
function formatDuration(duration) {
  if (duration < 1e3)
    return `${duration} ms`;
  if (duration < 1e4)
    return `${(duration / 1e3).toFixed(3)} s`;
  if (duration < 6e4)
    return `${(duration / 1e3).toFixed(1)} s`;
  return `${(duration / 1e3).toFixed(0)} s`;
}
function withTimeout(promise, duration) {
  return new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      rej(`Promise timed out after ${duration}ms`);
    }, duration);
    promise.then(res).catch(rej).finally(() => clearTimeout(timeout));
  });
}

// src/core/utils/network.ts
function isOffline() {
  const isOffline2 = new Promise((res) => {
    dns.resolve("google.com", (err) => {
      if (err == null) {
        res(false);
      } else {
        res(true);
      }
    });
  });
  return withTimeout(isOffline2, 1e3).catch(() => true);
}
async function isOnline() {
  const offline = await isOffline();
  return !offline;
}
async function fetchCached(url, config) {
  let content = "";
  if (await isOnline()) {
    const res = await fetch(url);
    if (res.status < 300) {
      content = await res.text();
      await config.fsCache.set(url, content);
    } else {
      config.logger.debug(
        `Failed to download "${url}", falling back to cache...`
      );
    }
  }
  if (!content)
    content = await config.fsCache.get(url) ?? "";
  if (!content)
    throw Error(
      `Offline and "${url}" has not been cached. Try again when online.`
    );
  return content;
}

// src/core/builders/vite/plugins/download.ts
function download(config) {
  return {
    name: "wxt:download",
    resolveId(id) {
      if (id.startsWith("url:"))
        return "\0" + id;
    },
    async load(id) {
      if (!id.startsWith("\0url:"))
        return;
      const url = id.replace("\0url:", "");
      return await fetchCached(url, config);
    }
  };
}

// src/core/builders/vite/plugins/multipageMove.ts
import { dirname as dirname4, extname, resolve as resolve7, join } from "node:path";
import fs6, { ensureDir as ensureDir2 } from "fs-extra";
function multipageMove(entrypoints, config) {
  return {
    name: "wxt:multipage-move",
    async writeBundle(_, bundle) {
      for (const oldBundlePath in bundle) {
        const entrypoint = entrypoints.find(
          (entry) => !!normalizePath(entry.inputPath).endsWith(oldBundlePath)
        );
        if (entrypoint == null) {
          config.logger.debug(
            `No entrypoint found for ${oldBundlePath}, leaving in chunks directory`
          );
          continue;
        }
        const newBundlePath = getEntrypointBundlePath(
          entrypoint,
          config.outDir,
          extname(oldBundlePath)
        );
        if (newBundlePath === oldBundlePath) {
          config.logger.debug(
            "HTML file is already in the correct location",
            oldBundlePath
          );
          continue;
        }
        const oldAbsPath = resolve7(config.outDir, oldBundlePath);
        const newAbsPath = resolve7(config.outDir, newBundlePath);
        await ensureDir2(dirname4(newAbsPath));
        await fs6.move(oldAbsPath, newAbsPath, { overwrite: true });
        const renamedChunk = {
          ...bundle[oldBundlePath],
          fileName: newBundlePath
        };
        delete bundle[oldBundlePath];
        bundle[newBundlePath] = renamedChunk;
      }
      removeEmptyDirs(config.outDir);
    }
  };
}
async function removeEmptyDirs(dir) {
  const files = await fs6.readdir(dir);
  for (const file of files) {
    const filePath = join(dir, file);
    const stats = await fs6.stat(filePath);
    if (stats.isDirectory()) {
      await removeEmptyDirs(filePath);
    }
  }
  try {
    await fs6.rmdir(dir);
  } catch {
  }
}

// src/core/builders/vite/plugins/unimport.ts
import { createUnimport as createUnimport2 } from "unimport";
import { extname as extname2 } from "path";
var ENABLED_EXTENSIONS = /* @__PURE__ */ new Set([
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".vue",
  ".svelte"
]);
function unimport(config) {
  const options = config.imports;
  if (options === false)
    return [];
  const unimport2 = createUnimport2(options);
  return {
    name: "wxt:unimport",
    async config() {
      await unimport2.scanImportsFromDir(void 0, { cwd: config.srcDir });
    },
    async transform(code, id) {
      if (id.includes("node_modules"))
        return;
      if (!ENABLED_EXTENSIONS.has(extname2(id)))
        return;
      const injected = await unimport2.injectImports(code, id);
      return {
        code: injected.code,
        map: injected.s.generateMap({ hires: "boundary", source: id })
      };
    }
  };
}

// src/core/builders/vite/plugins/virtualEntrypoint.ts
import fs7 from "fs-extra";
import { resolve as resolve8 } from "path";
function virtualEntrypoint(type, config) {
  const virtualId = `virtual:wxt-${type}?`;
  const resolvedVirtualId = `\0${virtualId}`;
  return {
    name: `wxt:virtual-entrypoint`,
    resolveId(id) {
      const index = id.indexOf(virtualId);
      if (index === -1)
        return;
      const inputPath = normalizePath(id.substring(index + virtualId.length));
      return resolvedVirtualId + inputPath;
    },
    async load(id) {
      if (!id.startsWith(resolvedVirtualId))
        return;
      const inputPath = id.replace(resolvedVirtualId, "");
      const template = await fs7.readFile(
        resolve8(
          config.root,
          `node_modules/wxt/dist/virtual/${type}-entrypoint.js`
        ),
        "utf-8"
      );
      return template.replace(`virtual:user-${type}`, inputPath);
    }
  };
}

// src/core/builders/vite/plugins/tsconfigPaths.ts
function tsconfigPaths(config) {
  return {
    name: "wxt:aliases",
    async config() {
      return {
        resolve: {
          alias: config.alias
        }
      };
    }
  };
}

// src/core/builders/vite/plugins/noopBackground.ts
function noopBackground() {
  const virtualModuleId = VIRTUAL_NOOP_BACKGROUND_MODULE_ID;
  const resolvedVirtualModuleId = "\0" + virtualModuleId;
  return {
    name: "wxt:noop-background",
    resolveId(id) {
      if (id === virtualModuleId)
        return resolvedVirtualModuleId;
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `import { defineBackground } from 'wxt/sandbox';
export default defineBackground(() => void 0)`;
      }
    }
  };
}

// src/core/builders/vite/plugins/cssEntrypoints.ts
function cssEntrypoints(entrypoint, config) {
  return {
    name: "wxt:css-entrypoint",
    config() {
      return {
        build: {
          rollupOptions: {
            output: {
              assetFileNames: () => getEntrypointBundlePath(entrypoint, config.outDir, ".css")
            }
          }
        }
      };
    },
    generateBundle(_, bundle) {
      Object.keys(bundle).forEach((file) => {
        if (file.endsWith(".js"))
          delete bundle[file];
      });
    }
  };
}

// src/core/builders/vite/plugins/bundleAnalysis.ts
import { visualizer } from "rollup-plugin-visualizer";
import path3 from "node:path";
var increment = 0;
function bundleAnalysis(config) {
  return visualizer({
    template: "raw-data",
    filename: path3.resolve(
      config.analysis.outputDir,
      `${config.analysis.outputName}-${increment++}.json`
    )
  });
}

// src/core/builders/vite/plugins/globals.ts
function globals(config) {
  return {
    name: "wxt:globals",
    config() {
      const define = {};
      for (const global of getGlobals(config)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/excludeBrowserPolyfill.ts
function excludeBrowserPolyfill(config) {
  const virtualId = "virtual:wxt-webextension-polyfill-disabled";
  return {
    name: "wxt:exclude-browser-polyfill",
    config() {
      if (config.experimental.includeBrowserPolyfill)
        return;
      return {
        resolve: {
          alias: {
            "webextension-polyfill": virtualId
          }
        }
      };
    },
    load(id) {
      if (id === virtualId) {
        return "export default chrome";
      }
    }
  };
}

// src/core/builders/vite/plugins/entrypointGroupGlobals.ts
function entrypointGroupGlobals(entrypointGroup) {
  return {
    name: "wxt:entrypoint-group-globals",
    config() {
      const define = {};
      let name = Array.isArray(entrypointGroup) ? "html" : entrypointGroup.name;
      for (const global of getEntrypointGlobals(name)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/defineImportMeta.ts
function defineImportMeta() {
  return {
    name: "wxt:define",
    config() {
      return {
        define: {
          // This works for all extension contexts, including background service worker
          "import.meta.url": "self.location.href"
        }
      };
    }
  };
}

// src/core/builders/vite/index.ts
async function createViteBuilder(inlineConfig, userConfig, wxtConfig) {
  const vite = await import("vite");
  const getBaseConfig = async () => {
    const resolvedInlineConfig = await inlineConfig.vite?.(wxtConfig.env) ?? {};
    const resolvedUserConfig = await userConfig.vite?.(wxtConfig.env) ?? {};
    const config = vite.mergeConfig(
      resolvedUserConfig,
      resolvedInlineConfig
    );
    config.root = wxtConfig.root;
    config.configFile = false;
    config.logLevel = "warn";
    config.mode = wxtConfig.mode;
    config.build ??= {};
    config.build.outDir = wxtConfig.outDir;
    config.build.emptyOutDir = false;
    if (config.build.minify == null && wxtConfig.command === "serve") {
      config.build.minify = false;
    }
    if (config.build.sourcemap == null && wxtConfig.command === "serve") {
      config.build.sourcemap = "inline";
    }
    config.plugins ??= [];
    config.plugins.push(
      download(wxtConfig),
      devHtmlPrerender(wxtConfig),
      unimport(wxtConfig),
      virtualEntrypoint("background", wxtConfig),
      virtualEntrypoint("content-script-isolated-world", wxtConfig),
      virtualEntrypoint("content-script-main-world", wxtConfig),
      virtualEntrypoint("unlisted-script", wxtConfig),
      devServerGlobals(wxtConfig),
      tsconfigPaths(wxtConfig),
      noopBackground(),
      globals(wxtConfig),
      excludeBrowserPolyfill(wxtConfig),
      defineImportMeta()
    );
    if (wxtConfig.analysis.enabled) {
      config.plugins.push(bundleAnalysis(wxtConfig));
    }
    return config;
  };
  const getLibModeConfig = (entrypoint) => {
    const entry = getRollupEntry(entrypoint);
    const plugins = [
      entrypointGroupGlobals(entrypoint)
    ];
    if (entrypoint.type === "content-script-style" || entrypoint.type === "unlisted-style") {
      plugins.push(cssEntrypoints(entrypoint, wxtConfig));
    }
    const libMode = {
      mode: wxtConfig.mode,
      plugins,
      build: {
        lib: {
          entry,
          formats: ["iife"],
          name: "_",
          fileName: entrypoint.name
        },
        rollupOptions: {
          output: {
            // There's only a single output for this build, so we use the desired bundle path for the
            // entry output (like "content-scripts/overlay.js")
            entryFileNames: getEntrypointBundlePath(
              entrypoint,
              wxtConfig.outDir,
              ".js"
            ),
            // Output content script CSS to `content-scripts/`, but all other scripts are written to
            // `assets/`.
            assetFileNames: ({ name }) => {
              if (entrypoint.type === "content-script" && name?.endsWith("css")) {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      },
      define: {
        // See https://github.com/aklinker1/vite-plugin-web-extension/issues/96
        "process.env.NODE_ENV": JSON.stringify(wxtConfig.mode)
      }
    };
    return libMode;
  };
  const getMultiPageConfig = (entrypoints) => {
    const htmlEntrypoints = new Set(
      entrypoints.filter(isHtmlEntrypoint).map((e) => e.name)
    );
    return {
      mode: wxtConfig.mode,
      plugins: [
        multipageMove(entrypoints, wxtConfig),
        entrypointGroupGlobals(entrypoints)
      ],
      build: {
        rollupOptions: {
          input: entrypoints.reduce((input, entry) => {
            input[entry.name] = getRollupEntry(entry);
            return input;
          }, {}),
          output: {
            // Include a hash to prevent conflicts
            chunkFileNames: "chunks/[name]-[hash].js",
            entryFileNames: ({ name }) => {
              if (htmlEntrypoints.has(name))
                return "chunks/[name]-[hash].js";
              return "[name].js";
            },
            // We can't control the "name", so we need a hash to prevent conflicts
            assetFileNames: "assets/[name]-[hash].[ext]"
          }
        }
      }
    };
  };
  const getCssConfig = (entrypoint) => {
    return {
      mode: wxtConfig.mode,
      plugins: [entrypointGroupGlobals(entrypoint)],
      build: {
        rollupOptions: {
          input: {
            [entrypoint.name]: entrypoint.inputPath
          },
          output: {
            assetFileNames: () => {
              if (entrypoint.type === "content-script-style") {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      }
    };
  };
  return {
    name: "Vite",
    version: vite.version,
    async build(group) {
      let entryConfig;
      if (Array.isArray(group))
        entryConfig = getMultiPageConfig(group);
      else if (group.inputPath.endsWith(".css"))
        entryConfig = getCssConfig(group);
      else
        entryConfig = getLibModeConfig(group);
      const buildConfig = vite.mergeConfig(await getBaseConfig(), entryConfig);
      const result = await vite.build(buildConfig);
      return {
        entrypoints: group,
        chunks: getBuildOutputChunks(result)
      };
    },
    async createServer(info) {
      const serverConfig = {
        server: {
          port: info.port,
          strictPort: true,
          host: info.hostname,
          origin: info.origin
        }
      };
      const baseConfig = await getBaseConfig();
      const viteServer = await vite.createServer(
        vite.mergeConfig(baseConfig, serverConfig)
      );
      const server = {
        async listen() {
          await viteServer.listen(info.port);
        },
        async close() {
          await viteServer.close();
        },
        transformHtml(...args) {
          return viteServer.transformIndexHtml(...args);
        },
        ws: {
          send(message, payload) {
            return viteServer.ws.send(message, payload);
          },
          on(message, cb) {
            viteServer.ws.on(message, cb);
          }
        },
        watcher: viteServer.watcher
      };
      return server;
    }
  };
}
function getBuildOutputChunks(result) {
  if ("on" in result)
    throw Error("wxt does not support vite watch mode.");
  if (Array.isArray(result))
    return result.flatMap(({ output }) => output);
  return result.output;
}
function getRollupEntry(entrypoint) {
  let virtualEntrypointType;
  switch (entrypoint.type) {
    case "background":
    case "unlisted-script":
      virtualEntrypointType = entrypoint.type;
      break;
    case "content-script":
      virtualEntrypointType = entrypoint.options.world === "MAIN" ? "content-script-main-world" : "content-script-isolated-world";
      break;
  }
  return virtualEntrypointType ? `virtual:wxt-${virtualEntrypointType}?${entrypoint.inputPath}` : entrypoint.inputPath;
}

// src/core/utils/building/resolve-config.ts
import defu from "defu";

// src/core/utils/package.ts
import { resolve as resolve9 } from "node:path";
import fs8 from "fs-extra";
async function getPackageJson() {
  const file = resolve9(wxt.config.root, "package.json");
  try {
    return await fs8.readJson(file);
  } catch (err) {
    wxt.logger.debug(
      `Failed to read package.json at: ${file}. Returning undefined.`
    );
    return {};
  }
}
function isModuleInstalled(name) {
  return import(name).then(() => true).catch(() => false);
}

// src/core/utils/building/resolve-config.ts
async function resolveConfig(inlineConfig, command, server) {
  let userConfig = {};
  let userConfigMetadata;
  if (inlineConfig.configFile !== false) {
    const { config: loadedConfig, ...metadata } = await loadConfig({
      configFile: inlineConfig.configFile,
      name: "wxt",
      cwd: inlineConfig.root ?? process.cwd(),
      rcFile: false,
      jitiOptions: {
        esmResolve: true
      }
    });
    userConfig = loadedConfig ?? {};
    userConfigMetadata = metadata;
  }
  const mergedConfig = mergeInlineConfig(inlineConfig, userConfig);
  const debug = mergedConfig.debug ?? false;
  const logger = mergedConfig.logger ?? consola;
  if (debug)
    logger.level = LogLevels.debug;
  const browser = mergedConfig.browser ?? "chrome";
  const manifestVersion = mergedConfig.manifestVersion ?? (browser === "firefox" || browser === "safari" ? 2 : 3);
  const mode = mergedConfig.mode ?? (command === "build" ? "production" : "development");
  const env = { browser, command, manifestVersion, mode };
  const root = path4.resolve(
    inlineConfig.root ?? userConfig.root ?? process.cwd()
  );
  const wxtDir = path4.resolve(root, ".wxt");
  const srcDir = path4.resolve(root, mergedConfig.srcDir ?? root);
  const entrypointsDir = path4.resolve(
    srcDir,
    mergedConfig.entrypointsDir ?? "entrypoints"
  );
  const filterEntrypoints = !!mergedConfig.filterEntrypoints?.length ? new Set(mergedConfig.filterEntrypoints) : void 0;
  const publicDir = path4.resolve(srcDir, mergedConfig.publicDir ?? "public");
  const typesDir = path4.resolve(wxtDir, "types");
  const outBaseDir = path4.resolve(root, mergedConfig.outDir ?? ".output");
  const outDir = path4.resolve(outBaseDir, `${browser}-mv${manifestVersion}`);
  const reloadCommand = mergedConfig.dev?.reloadCommand ?? "Alt+R";
  const runnerConfig = await loadConfig({
    name: "web-ext",
    cwd: root,
    globalRc: true,
    rcFile: ".webextrc",
    overrides: inlineConfig.runner,
    defaults: userConfig.runner
  });
  const alias = Object.fromEntries(
    Object.entries({
      ...mergedConfig.alias,
      "@": srcDir,
      "~": srcDir,
      "@@": root,
      "~~": root
    }).map(([key, value]) => [key, path4.resolve(root, value)])
  );
  const analysisOutputFile = path4.resolve(
    root,
    mergedConfig.analysis?.outputFile ?? "stats.html"
  );
  const analysisOutputDir = path4.dirname(analysisOutputFile);
  const analysisOutputName = path4.parse(analysisOutputFile).name;
  const finalConfig = {
    browser,
    command,
    debug,
    entrypointsDir,
    filterEntrypoints,
    env,
    fsCache: createFsCache(wxtDir),
    imports: await getUnimportOptions(wxtDir, logger, mergedConfig),
    logger,
    manifest: await resolveManifestConfig(env, mergedConfig.manifest),
    manifestVersion,
    mode,
    outBaseDir,
    outDir,
    publicDir,
    root,
    runnerConfig,
    srcDir,
    typesDir,
    wxtDir,
    zip: resolveInternalZipConfig(root, mergedConfig),
    transformManifest(manifest) {
      userConfig.transformManifest?.(manifest);
      inlineConfig.transformManifest?.(manifest);
    },
    analysis: {
      enabled: mergedConfig.analysis?.enabled ?? false,
      template: mergedConfig.analysis?.template ?? "treemap",
      outputFile: analysisOutputFile,
      outputDir: analysisOutputDir,
      outputName: analysisOutputName,
      keepArtifacts: mergedConfig.analysis?.keepArtifacts ?? false
    },
    userConfigMetadata: userConfigMetadata ?? {},
    alias,
    experimental: {
      includeBrowserPolyfill: mergedConfig.experimental?.includeBrowserPolyfill ?? true
    },
    server,
    dev: {
      reloadCommand
    },
    hooks: mergedConfig.hooks ?? {}
  };
  const builder = await createViteBuilder(
    inlineConfig,
    userConfig,
    finalConfig
  );
  return {
    ...finalConfig,
    builder
  };
}
async function resolveManifestConfig(env, manifest) {
  return await (typeof manifest === "function" ? manifest(env) : manifest ?? {});
}
function mergeInlineConfig(inlineConfig, userConfig) {
  let imports;
  if (inlineConfig.imports === false || userConfig.imports === false) {
    imports = false;
  } else if (userConfig.imports == null && inlineConfig.imports == null) {
    imports = void 0;
  } else {
    imports = defu(inlineConfig.imports ?? {}, userConfig.imports ?? {});
  }
  const manifest = async (env) => {
    const user = await resolveManifestConfig(env, userConfig.manifest);
    const inline = await resolveManifestConfig(env, inlineConfig.manifest);
    return defu(inline, user);
  };
  const runner = defu(
    inlineConfig.runner ?? {},
    userConfig.runner ?? {}
  );
  const zip2 = defu(
    inlineConfig.zip ?? {},
    userConfig.zip ?? {}
  );
  const hooks = defu(
    inlineConfig.hooks ?? {},
    userConfig.hooks ?? {}
  );
  return {
    root: inlineConfig.root ?? userConfig.root,
    browser: inlineConfig.browser ?? userConfig.browser,
    manifestVersion: inlineConfig.manifestVersion ?? userConfig.manifestVersion,
    configFile: inlineConfig.configFile,
    debug: inlineConfig.debug ?? userConfig.debug,
    entrypointsDir: inlineConfig.entrypointsDir ?? userConfig.entrypointsDir,
    filterEntrypoints: inlineConfig.filterEntrypoints ?? userConfig.filterEntrypoints,
    imports,
    logger: inlineConfig.logger ?? userConfig.logger,
    manifest,
    mode: inlineConfig.mode ?? userConfig.mode,
    publicDir: inlineConfig.publicDir ?? userConfig.publicDir,
    runner,
    srcDir: inlineConfig.srcDir ?? userConfig.srcDir,
    outDir: inlineConfig.outDir ?? userConfig.outDir,
    zip: zip2,
    analysis: {
      ...userConfig.analysis,
      ...inlineConfig.analysis
    },
    alias: {
      ...userConfig.alias,
      ...inlineConfig.alias
    },
    experimental: {
      ...userConfig.experimental,
      ...inlineConfig.experimental
    },
    vite: void 0,
    transformManifest: void 0,
    dev: {
      ...userConfig.dev,
      ...inlineConfig.dev
    },
    hooks
  };
}
function resolveInternalZipConfig(root, mergedConfig) {
  return {
    name: void 0,
    sourcesTemplate: "{{name}}-{{version}}-sources.zip",
    artifactTemplate: "{{name}}-{{version}}-{{browser}}.zip",
    sourcesRoot: root,
    includeSources: [],
    ...mergedConfig.zip,
    excludeSources: [
      "**/node_modules",
      // WXT files
      "**/web-ext.config.ts",
      // Hidden files
      "**/.*",
      // Tests
      "**/__tests__/**",
      "**/*.+(test|spec).?(c|m)+(j|t)s?(x)",
      // From user
      ...mergedConfig.zip?.excludeSources ?? []
    ]
  };
}
async function getUnimportOptions(wxtDir, logger, config) {
  if (config.imports === false)
    return false;
  const enabledConfig = config.imports?.eslintrc?.enabled;
  let enabled;
  switch (enabledConfig) {
    case void 0:
    case "auto":
      enabled = await isModuleInstalled("eslint");
      break;
    default:
      enabled = enabledConfig;
  }
  const defaultOptions = {
    debugLog: logger.debug,
    imports: [
      { name: "defineConfig", from: "wxt" },
      { name: "fakeBrowser", from: "wxt/testing" }
    ],
    presets: [
      { package: "wxt/client" },
      { package: "wxt/browser" },
      { package: "wxt/sandbox" },
      { package: "wxt/storage" }
    ],
    warn: logger.warn,
    dirs: ["components", "composables", "hooks", "utils"],
    eslintrc: {
      enabled,
      filePath: path4.resolve(wxtDir, "eslintrc-auto-import.json"),
      globalsPropValue: true
    }
  };
  return defu(
    config.imports ?? {},
    defaultOptions
  );
}

// src/core/utils/building/group-entrypoints.ts
function groupEntrypoints(entrypoints) {
  const groupIndexMap = {};
  const groups = [];
  for (const entry of entrypoints) {
    let group = ENTRY_TYPE_TO_GROUP_MAP[entry.type];
    if (entry.type === "background" && entry.options.type === "module") {
      group = "esm";
    }
    if (group === "individual") {
      groups.push(entry);
    } else {
      let groupIndex = groupIndexMap[group];
      if (groupIndex == null) {
        groupIndex = groups.push([]) - 1;
        groupIndexMap[group] = groupIndex;
      }
      groups[groupIndex].push(entry);
    }
  }
  return groups;
}
var ENTRY_TYPE_TO_GROUP_MAP = {
  sandbox: "sandboxed-esm",
  popup: "esm",
  newtab: "esm",
  history: "esm",
  options: "esm",
  devtools: "esm",
  bookmarks: "esm",
  sidepanel: "esm",
  "unlisted-page": "esm",
  background: "individual",
  "content-script": "individual",
  "unlisted-script": "individual",
  "unlisted-style": "individual",
  "content-script-style": "individual"
};

// src/core/utils/building/import-entrypoint.ts
import createJITI from "jiti";
import { createUnimport as createUnimport3 } from "unimport";
import fs9 from "fs-extra";
import { relative as relative5, resolve as resolve10 } from "node:path";

// src/core/utils/strings.ts
function kebabCaseAlphanumeric(str) {
  return str.toLowerCase().replace(/[^a-z0-9-\s]/g, "").replace(/\s+/g, "-");
}
function removeImportStatements(text) {
  return text.replace(
    /(import\s?[{\w][\s\S]*?from\s?["'][\s\S]*?["'];?|import\s?["'][\s\S]*?["'];?)/gm,
    ""
  );
}
function removeProjectImportStatements(text) {
  const noImports = removeImportStatements(text);
  return `import { defineUnlistedScript, defineContentScript, defineBackground } from 'wxt/sandbox';

${noImports}`;
}

// src/core/utils/building/import-entrypoint.ts
import { transformSync } from "esbuild";
import { fileURLToPath } from "node:url";
async function importEntrypointFile(path8) {
  wxt.logger.debug("Loading file metadata:", path8);
  const normalPath = normalizePath(path8);
  const unimport2 = createUnimport3({
    ...wxt.config.imports,
    // Only allow specific imports, not all from the project
    dirs: []
  });
  await unimport2.init();
  const text = await fs9.readFile(path8, "utf-8");
  const textNoImports = removeProjectImportStatements(text);
  const { code } = await unimport2.injectImports(textNoImports);
  wxt.logger.debug(
    ["Text:", text, "No imports:", textNoImports, "Code:", code].join("\n")
  );
  const jiti = createJITI(
    typeof __filename !== "undefined" ? __filename : fileURLToPath(import.meta.url),
    {
      cache: false,
      debug: wxt.config.debug,
      esmResolve: true,
      alias: {
        "webextension-polyfill": resolve10(
          wxt.config.root,
          "node_modules/wxt/dist/virtual/mock-browser.js"
        )
      },
      // Continue using node to load TS files even if `bun run --bun` is detected. Jiti does not
      // respect the custom transform function when using it's native bun option.
      experimentalBun: false,
      // List of extensions to transform with esbuild
      extensions: [
        ".ts",
        ".cts",
        ".mts",
        ".tsx",
        ".js",
        ".cjs",
        ".mjs",
        ".jsx"
      ],
      transform(opts) {
        const isEntrypoint = opts.filename === normalPath;
        return transformSync(
          // Use modified source code for entrypoints
          isEntrypoint ? code : opts.source,
          getEsbuildOptions(opts)
        );
      }
    }
  );
  try {
    const res = await jiti(path8);
    return res.default;
  } catch (err) {
    const filePath = relative5(wxt.config.root, path8);
    if (err instanceof ReferenceError) {
      const variableName = err.message.replace(" is not defined", "");
      throw Error(
        `${filePath}: Cannot use imported variable "${variableName}" outside the main function. See https://wxt.dev/guide/entrypoints.html#side-effects`,
        { cause: err }
      );
    } else {
      wxt.logger.error(err);
      throw Error(`Failed to load entrypoint: ${filePath}`, { cause: err });
    }
  }
}
function getEsbuildOptions(opts) {
  const isJsx = opts.filename?.endsWith("x");
  return {
    format: "cjs",
    loader: isJsx ? "tsx" : "ts",
    ...isJsx ? {
      // `h` and `Fragment` are undefined, but that's OK because JSX is never evaluated while
      // grabbing the entrypoint's options.
      jsxFactory: "h",
      jsxFragment: "Fragment"
    } : void 0
  };
}

// src/core/utils/building/internal-build.ts
import pc5 from "picocolors";
import fs12 from "fs-extra";

// src/core/utils/log/printBuildSummary.ts
import { resolve as resolve11 } from "path";

// src/core/utils/log/printFileList.ts
import path5 from "node:path";
import pc3 from "picocolors";
import fs10 from "fs-extra";
import { filesize } from "filesize";

// src/core/utils/log/printTable.ts
function printTable(log, header, rows, gap = 2) {
  if (rows.length === 0)
    return;
  const columnWidths = rows.reduce(
    (widths, row) => {
      for (let i = 0; i < Math.max(widths.length, row.length); i++) {
        widths[i] = Math.max(row[i]?.length ?? 0, widths[i] ?? 0);
      }
      return widths;
    },
    rows[0].map((column) => column.length)
  );
  let str = "";
  rows.forEach((row, i) => {
    row.forEach((col, j) => {
      str += col.padEnd(columnWidths[j], " ");
      if (j !== row.length - 1)
        str += "".padEnd(gap, " ");
    });
    if (i !== rows.length - 1)
      str += "\n";
  });
  log(`${header}
${str}`);
}

// src/core/utils/log/printFileList.ts
async function printFileList(log, header, baseDir, files) {
  let totalSize = 0;
  const fileRows = await Promise.all(
    files.map(async (file, i) => {
      const parts = [
        path5.relative(process.cwd(), baseDir) + path5.sep,
        path5.relative(baseDir, file)
      ];
      const prefix = i === files.length - 1 ? "  \u2514\u2500" : "  \u251C\u2500";
      const color = getChunkColor(file);
      const stats = await fs10.lstat(file);
      totalSize += stats.size;
      const size = String(filesize(stats.size));
      return [
        `${pc3.gray(prefix)} ${pc3.dim(parts[0])}${color(parts[1])}`,
        pc3.dim(size)
      ];
    })
  );
  fileRows.push([`${pc3.cyan("\u03A3 Total size:")} ${String(filesize(totalSize))}`]);
  printTable(log, header, fileRows);
}
var DEFAULT_COLOR = pc3.blue;
var CHUNK_COLORS = {
  ".js.map": pc3.gray,
  ".cjs.map": pc3.gray,
  ".mjs.map": pc3.gray,
  ".html": pc3.green,
  ".css": pc3.magenta,
  ".js": pc3.cyan,
  ".cjs": pc3.cyan,
  ".mjs": pc3.cyan,
  ".zip": pc3.yellow
};
function getChunkColor(filename) {
  return Object.entries(CHUNK_COLORS).find(([key]) => filename.endsWith(key))?.[1] ?? DEFAULT_COLOR;
}

// src/core/utils/log/printBuildSummary.ts
async function printBuildSummary(log, header, output) {
  const chunks = [
    ...output.steps.flatMap((step) => step.chunks),
    ...output.publicAssets
  ].sort((l, r) => {
    const lWeight = getChunkSortWeight(l.fileName);
    const rWeight = getChunkSortWeight(r.fileName);
    const diff = lWeight - rWeight;
    if (diff !== 0)
      return diff;
    return l.fileName.localeCompare(r.fileName);
  });
  const files = chunks.map(
    (chunk) => resolve11(wxt.config.outDir, chunk.fileName)
  );
  await printFileList(log, header, wxt.config.outDir, files);
}
var DEFAULT_SORT_WEIGHT = 100;
var CHUNK_SORT_WEIGHTS = {
  "manifest.json": 0,
  ".html": 1,
  ".js.map": 2,
  ".js": 2,
  ".css": 3
};
function getChunkSortWeight(filename) {
  return Object.entries(CHUNK_SORT_WEIGHTS).find(
    ([key]) => filename.endsWith(key)
  )?.[1] ?? DEFAULT_SORT_WEIGHT;
}

// src/core/utils/log/printHeader.ts
import pc4 from "picocolors";

// package.json
var version = "0.16.11";

// src/core/utils/log/printHeader.ts
import { consola as consola2 } from "consola";
function printHeader() {
  console.log();
  consola2.log(`${pc4.gray("WXT")} ${pc4.gray(pc4.bold(version))}`);
}

// src/core/utils/building/internal-build.ts
import glob3 from "fast-glob";

// src/core/utils/manifest.ts
import fs11 from "fs-extra";
import { resolve as resolve12 } from "path";

// src/core/utils/content-security-policy.ts
var ContentSecurityPolicy = class _ContentSecurityPolicy {
  static DIRECTIVE_ORDER = {
    "default-src": 0,
    "script-src": 1,
    "object-src": 2
  };
  data;
  constructor(csp) {
    if (csp) {
      const sections = csp.split(";").map((section) => section.trim());
      this.data = sections.reduce((data, section) => {
        const [key, ...values] = section.split(" ").map((item) => item.trim());
        if (key)
          data[key] = values;
        return data;
      }, {});
    } else {
      this.data = {};
    }
  }
  /**
   * Ensure a set of values are listed under a directive.
   */
  add(directive, ...newValues) {
    const values = this.data[directive] ?? [];
    newValues.forEach((newValue) => {
      if (!values.includes(newValue))
        values.push(newValue);
    });
    this.data[directive] = values;
    return this;
  }
  toString() {
    const directives = Object.entries(this.data).sort(([l], [r]) => {
      const lo = _ContentSecurityPolicy.DIRECTIVE_ORDER[l] ?? 2;
      const ro = _ContentSecurityPolicy.DIRECTIVE_ORDER[r] ?? 2;
      return lo - ro;
    });
    return directives.map((entry) => entry.flat().join(" ")).join("; ") + ";";
  }
};

// src/core/utils/content-scripts.ts
function hashContentScriptOptions(options) {
  const simplifiedOptions = mapWxtOptionsToContentScript(
    options,
    void 0,
    void 0
  );
  Object.keys(simplifiedOptions).forEach((key) => {
    if (simplifiedOptions[key] == null)
      delete simplifiedOptions[key];
  });
  const withDefaults = {
    exclude_globs: [],
    exclude_matches: [],
    include_globs: [],
    match_about_blank: false,
    run_at: "document_idle",
    all_frames: false,
    // @ts-expect-error - not in type
    match_origin_as_fallback: false,
    world: "ISOLATED",
    ...simplifiedOptions
  };
  return JSON.stringify(
    Object.entries(withDefaults).map(([key, value]) => {
      if (Array.isArray(value))
        return [key, value.sort()];
      else
        return [key, value];
    }).sort((l, r) => l[0].localeCompare(r[0]))
  );
}
function mapWxtOptionsToContentScript(options, js, css) {
  return {
    matches: options.matches,
    all_frames: options.allFrames,
    match_about_blank: options.matchAboutBlank,
    exclude_globs: options.excludeGlobs,
    exclude_matches: options.excludeMatches,
    include_globs: options.includeGlobs,
    run_at: options.runAt,
    css,
    js,
    // @ts-expect-error: untyped chrome options
    match_origin_as_fallback: options.matchOriginAsFallback,
    world: options.world
  };
}
function mapWxtOptionsToRegisteredContentScript(options, js, css) {
  return {
    allFrames: options.allFrames,
    excludeMatches: options.excludeMatches,
    matches: options.matches,
    runAt: options.runAt,
    js,
    css,
    // @ts-expect-error: Chrome accepts this, not typed in webextension-polyfill (https://developer.chrome.com/docs/extensions/reference/scripting/#type-RegisteredContentScript)
    world: options.world
  };
}

// src/core/utils/manifest.ts
import defu2 from "defu";
async function writeManifest(manifest, output) {
  const str = wxt.config.mode === "production" ? JSON.stringify(manifest) : JSON.stringify(manifest, null, 2);
  await fs11.ensureDir(wxt.config.outDir);
  await writeFileIfDifferent(resolve12(wxt.config.outDir, "manifest.json"), str);
  output.publicAssets.unshift({
    type: "asset",
    fileName: "manifest.json"
  });
}
async function generateManifest(entrypoints, buildOutput) {
  const warnings = [];
  const pkg = await getPackageJson();
  let versionName = wxt.config.manifest.version_name ?? wxt.config.manifest.version ?? pkg?.version;
  if (versionName == null) {
    versionName = "0.0.0";
    wxt.logger.warn(
      'Extension version not found, defaulting to "0.0.0". Add a version to your `package.json` or `wxt.config.ts` file. For more details, see: https://wxt.dev/guide/manifest.html#version-and-version-name'
    );
  }
  const version2 = wxt.config.manifest.version ?? simplifyVersion(versionName);
  const baseManifest = {
    manifest_version: wxt.config.manifestVersion,
    name: pkg?.name,
    description: pkg?.description,
    version: version2,
    short_name: pkg?.shortName,
    icons: discoverIcons(buildOutput)
  };
  const userManifest = wxt.config.manifest;
  let manifest = defu2(
    userManifest,
    baseManifest
  );
  if (wxt.config.command === "serve" && wxt.config.dev.reloadCommand) {
    if (manifest.commands && Object.keys(manifest.commands).length >= 4) {
      warnings.push([
        "Extension already has 4 registered commands, WXT's reload command is disabled"
      ]);
    } else {
      manifest.commands ??= {};
      manifest.commands["wxt:reload-extension"] = {
        description: "Reload the extension during development",
        suggested_key: {
          default: wxt.config.dev.reloadCommand
        }
      };
    }
  }
  manifest.version = version2;
  manifest.version_name = // Firefox doesn't support version_name
  wxt.config.browser === "firefox" || versionName === version2 ? void 0 : versionName;
  addEntrypoints(manifest, entrypoints, buildOutput);
  if (wxt.config.command === "serve")
    addDevModeCsp(manifest);
  if (wxt.config.command === "serve")
    addDevModePermissions(manifest);
  wxt.config.transformManifest(manifest);
  await wxt.hooks.callHook("build:manifestGenerated", wxt, manifest);
  if (wxt.config.manifestVersion === 2)
    convertWebAccessibleResourcesToMv2(manifest);
  if (wxt.config.manifestVersion === 3) {
    validateMv3WebAccessbileResources(manifest);
  }
  if (manifest.name == null)
    throw Error(
      "Manifest 'name' is missing. Either:\n1. Set the name in your <rootDir>/package.json\n2. Set a name via the manifest option in your wxt.config.ts"
    );
  if (manifest.version == null) {
    throw Error(
      "Manifest 'version' is missing. Either:\n1. Add a version in your <rootDir>/package.json\n2. Pass the version via the manifest option in your wxt.config.ts"
    );
  }
  return {
    manifest,
    warnings
  };
}
function simplifyVersion(versionName) {
  const version2 = /^((0|[1-9][0-9]{0,8})([.](0|[1-9][0-9]{0,8})){0,3}).*$/.exec(
    versionName
  )?.[1];
  if (version2 == null)
    throw Error(
      `Cannot simplify package.json version "${versionName}" to a valid extension version, "X.Y.Z"`
    );
  return version2;
}
function addEntrypoints(manifest, entrypoints, buildOutput) {
  const entriesByType = entrypoints.reduce((map, entrypoint) => {
    map[entrypoint.type] ??= [];
    map[entrypoint.type]?.push(entrypoint);
    return map;
  }, {});
  const background = entriesByType["background"]?.[0];
  const bookmarks = entriesByType["bookmarks"]?.[0];
  const contentScripts = entriesByType["content-script"];
  const devtools = entriesByType["devtools"]?.[0];
  const history = entriesByType["history"]?.[0];
  const newtab = entriesByType["newtab"]?.[0];
  const options = entriesByType["options"]?.[0];
  const popup = entriesByType["popup"]?.[0];
  const sandboxes = entriesByType["sandbox"];
  const sidepanels = entriesByType["sidepanel"];
  if (background) {
    const script = getEntrypointBundlePath(
      background,
      wxt.config.outDir,
      ".js"
    );
    if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
      manifest.background = {
        type: background.options.type,
        scripts: [script]
      };
    } else if (wxt.config.manifestVersion === 3) {
      manifest.background = {
        type: background.options.type,
        service_worker: script
      };
    } else {
      manifest.background = {
        persistent: background.options.persistent,
        scripts: [script]
      };
    }
  }
  if (bookmarks) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Bookmarks are not supported by Firefox. chrome_url_overrides.bookmarks was not added to the manifest"
      );
    } else {
      manifest.chrome_url_overrides ??= {};
      manifest.chrome_url_overrides.bookmarks = getEntrypointBundlePath(
        bookmarks,
        wxt.config.outDir,
        ".html"
      );
    }
  }
  if (history) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Bookmarks are not supported by Firefox. chrome_url_overrides.history was not added to the manifest"
      );
    } else {
      manifest.chrome_url_overrides ??= {};
      manifest.chrome_url_overrides.history = getEntrypointBundlePath(
        history,
        wxt.config.outDir,
        ".html"
      );
    }
  }
  if (newtab) {
    manifest.chrome_url_overrides ??= {};
    manifest.chrome_url_overrides.newtab = getEntrypointBundlePath(
      newtab,
      wxt.config.outDir,
      ".html"
    );
  }
  if (popup) {
    const default_popup = getEntrypointBundlePath(
      popup,
      wxt.config.outDir,
      ".html"
    );
    const options2 = {};
    if (popup.options.defaultIcon)
      options2.default_icon = popup.options.defaultIcon;
    if (popup.options.defaultTitle)
      options2.default_title = popup.options.defaultTitle;
    if (popup.options.browserStyle)
      options2.browser_style = popup.options.browserStyle;
    if (manifest.manifest_version === 3) {
      manifest.action = {
        ...manifest.action ?? {},
        ...options2,
        default_popup
      };
    } else {
      const key = popup.options.mv2Key ?? "browser_action";
      manifest[key] = {
        ...manifest[key] ?? {},
        ...options2,
        default_popup
      };
    }
  }
  if (devtools) {
    manifest.devtools_page = getEntrypointBundlePath(
      devtools,
      wxt.config.outDir,
      ".html"
    );
  }
  if (options) {
    const page = getEntrypointBundlePath(options, wxt.config.outDir, ".html");
    manifest.options_ui = {
      open_in_tab: options.options.openInTab,
      browser_style: wxt.config.browser === "firefox" ? options.options.browserStyle : void 0,
      chrome_style: wxt.config.browser !== "firefox" ? options.options.chromeStyle : void 0,
      page
    };
  }
  if (sandboxes?.length) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Sandboxed pages not supported by Firefox. sandbox.pages was not added to the manifest"
      );
    } else {
      manifest.sandbox = {
        pages: sandboxes.map(
          (entry) => getEntrypointBundlePath(entry, wxt.config.outDir, ".html")
        )
      };
    }
  }
  if (sidepanels?.length) {
    const defaultSidepanel = sidepanels.find((entry) => entry.name === "sidepanel") ?? sidepanels[0];
    const page = getEntrypointBundlePath(
      defaultSidepanel,
      wxt.config.outDir,
      ".html"
    );
    if (wxt.config.browser === "firefox") {
      manifest.sidebar_action = {
        default_panel: page,
        browser_style: defaultSidepanel.options.browserStyle,
        default_icon: defaultSidepanel.options.defaultIcon,
        default_title: defaultSidepanel.options.defaultTitle,
        open_at_install: defaultSidepanel.options.openAtInstall
      };
    } else if (wxt.config.manifestVersion === 3) {
      manifest.side_panel = {
        default_path: page
      };
    } else {
      wxt.logger.warn(
        "Side panel not supported by Chromium using MV2. side_panel.default_path was not added to the manifest"
      );
    }
  }
  if (contentScripts?.length) {
    const cssMap = getContentScriptsCssMap(buildOutput, contentScripts);
    if (wxt.config.command === "serve" && wxt.config.manifestVersion === 3) {
      contentScripts.forEach((script) => {
        script.options.matches.forEach((matchPattern) => {
          addHostPermission(manifest, matchPattern);
        });
      });
    } else {
      const hashToEntrypointsMap = contentScripts.filter((cs) => cs.options.registration !== "runtime").reduce((map, script) => {
        const hash = hashContentScriptOptions(script.options);
        if (map.has(hash))
          map.get(hash)?.push(script);
        else
          map.set(hash, [script]);
        return map;
      }, /* @__PURE__ */ new Map());
      const manifestContentScripts = Array.from(
        hashToEntrypointsMap.values()
      ).map(
        (scripts) => mapWxtOptionsToContentScript(
          scripts[0].options,
          scripts.map(
            (entry) => getEntrypointBundlePath(entry, wxt.config.outDir, ".js")
          ),
          getContentScriptCssFiles(scripts, cssMap)
        )
      );
      if (manifestContentScripts.length >= 0) {
        manifest.content_scripts ??= [];
        manifest.content_scripts.push(...manifestContentScripts);
      }
      const runtimeContentScripts = contentScripts.filter(
        (cs) => cs.options.registration === "runtime"
      );
      if (runtimeContentScripts.length > 0 && wxt.config.manifestVersion === 2) {
        throw Error(
          'Cannot use `registration: "runtime"` with MV2 content scripts, it is a MV3-only feature.'
        );
      }
      runtimeContentScripts.forEach((script) => {
        script.options.matches.forEach((matchPattern) => {
          addHostPermission(manifest, matchPattern);
        });
      });
    }
    const contentScriptCssResources = getContentScriptCssWebAccessibleResources(
      contentScripts,
      cssMap
    );
    if (contentScriptCssResources.length > 0) {
      manifest.web_accessible_resources ??= [];
      manifest.web_accessible_resources.push(...contentScriptCssResources);
    }
  }
}
function discoverIcons(buildOutput) {
  const icons = [];
  const iconRegex = [
    /^icon-([0-9]+)\.png$/,
    // icon-16.png
    /^icon-([0-9]+)x[0-9]+\.png$/,
    // icon-16x16.png
    /^icon@([0-9]+)w\.png$/,
    // icon@16w.png
    /^icon@([0-9]+)h\.png$/,
    // icon@16h.png
    /^icon@([0-9]+)\.png$/,
    // icon@16.png
    /^icons?[\/\\]([0-9]+)\.png$/,
    // icon/16.png | icons/16.png
    /^icons?[\/\\]([0-9]+)x[0-9]+\.png$/
    // icon/16x16.png | icons/16x16.png
  ];
  buildOutput.publicAssets.forEach((asset) => {
    let size;
    for (const regex of iconRegex) {
      const match = asset.fileName.match(regex);
      if (match?.[1] != null) {
        size = match[1];
        break;
      }
    }
    if (size == null)
      return;
    icons.push([size, normalizePath(asset.fileName)]);
  });
  return icons.length > 0 ? Object.fromEntries(icons) : void 0;
}
function addDevModeCsp(manifest) {
  const permission = `http://${wxt.config.server?.hostname ?? ""}/*`;
  const allowedCsp = wxt.config.server?.origin ?? "http://localhost:*";
  if (manifest.manifest_version === 3) {
    addHostPermission(manifest, permission);
  } else {
    addPermission(manifest, permission);
  }
  const csp = new ContentSecurityPolicy(
    manifest.manifest_version === 3 ? (
      // @ts-expect-error: extension_pages is not typed
      manifest.content_security_policy?.extension_pages ?? "script-src 'self' 'wasm-unsafe-eval'; object-src 'self';"
    ) : manifest.content_security_policy ?? "script-src 'self'; object-src 'self';"
    // default CSP for MV2
  );
  if (wxt.config.server)
    csp.add("script-src", allowedCsp);
  if (manifest.manifest_version === 3) {
    manifest.content_security_policy ??= {};
    manifest.content_security_policy.extension_pages = csp.toString();
  } else {
    manifest.content_security_policy = csp.toString();
  }
}
function addDevModePermissions(manifest) {
  addPermission(manifest, "tabs");
  if (wxt.config.manifestVersion === 3)
    addPermission(manifest, "scripting");
}
function getContentScriptCssFiles(contentScripts, contentScriptCssMap) {
  const css = [];
  contentScripts.forEach((script) => {
    if (script.options.cssInjectionMode === "manual" || script.options.cssInjectionMode === "ui")
      return;
    const cssFile = contentScriptCssMap[script.name];
    if (cssFile == null)
      return;
    if (cssFile)
      css.push(cssFile);
  });
  if (css.length > 0)
    return css;
  return void 0;
}
function getContentScriptCssWebAccessibleResources(contentScripts, contentScriptCssMap) {
  const resources = [];
  contentScripts.forEach((script) => {
    if (script.options.cssInjectionMode !== "ui")
      return;
    const cssFile = contentScriptCssMap[script.name];
    if (cssFile == null)
      return;
    resources.push({
      resources: [cssFile],
      matches: script.options.matches.map(
        (matchPattern) => stripPathFromMatchPattern(matchPattern)
      )
    });
  });
  return resources;
}
function getContentScriptsCssMap(buildOutput, scripts) {
  const map = {};
  const allChunks = buildOutput.steps.flatMap((step) => step.chunks);
  scripts.forEach((script) => {
    const relatedCss = allChunks.find(
      (chunk) => chunk.fileName === `content-scripts/${script.name}.css`
    );
    if (relatedCss != null)
      map[script.name] = relatedCss.fileName;
  });
  return map;
}
function addPermission(manifest, permission) {
  manifest.permissions ??= [];
  if (manifest.permissions.includes(permission))
    return;
  manifest.permissions.push(permission);
}
function addHostPermission(manifest, hostPermission) {
  manifest.host_permissions ??= [];
  if (manifest.host_permissions.includes(hostPermission))
    return;
  manifest.host_permissions.push(hostPermission);
}
function stripPathFromMatchPattern(pattern) {
  const protocolSepIndex = pattern.indexOf("://");
  if (protocolSepIndex === -1)
    return pattern;
  const startOfPath = pattern.indexOf("/", protocolSepIndex + 3);
  return pattern.substring(0, startOfPath) + "/*";
}
function convertWebAccessibleResourcesToMv2(manifest) {
  if (manifest.web_accessible_resources == null)
    return;
  manifest.web_accessible_resources = Array.from(
    new Set(
      manifest.web_accessible_resources.flatMap((item) => {
        if (typeof item === "string")
          return item;
        return item.resources;
      })
    )
  );
}
function validateMv3WebAccessbileResources(manifest) {
  if (manifest.web_accessible_resources == null)
    return;
  const stringResources = manifest.web_accessible_resources.filter(
    (item) => typeof item === "string"
  );
  if (stringResources.length > 0) {
    throw Error(
      `Non-MV3 web_accessible_resources detected: ${JSON.stringify(
        stringResources
      )}. When manually defining web_accessible_resources, define them as MV3 objects ({ matches: [...], resources: [...] }), and WXT will automatically convert them to MV2 when necessary.`
    );
  }
}

// src/core/utils/building/rebuild.ts
async function rebuild(allEntrypoints, entrypointGroups, existingOutput = {
  steps: [],
  publicAssets: []
}) {
  const { default: ora } = await import("ora");
  const spinner = ora(`Preparing...`).start();
  await generateTypesDir(allEntrypoints).catch((err) => {
    wxt.logger.warn("Failed to update .wxt directory:", err);
    if (wxt.config.command === "build")
      throw err;
  });
  const newOutput = await buildEntrypoints(entrypointGroups, spinner);
  const mergedOutput = {
    steps: [...existingOutput.steps, ...newOutput.steps],
    publicAssets: [...existingOutput.publicAssets, ...newOutput.publicAssets]
  };
  const { manifest: newManifest, warnings: manifestWarnings } = await generateManifest(allEntrypoints, mergedOutput);
  const finalOutput = {
    manifest: newManifest,
    ...newOutput
  };
  await writeManifest(newManifest, finalOutput);
  spinner.clear().stop();
  return {
    output: {
      manifest: newManifest,
      steps: [...existingOutput.steps, ...finalOutput.steps],
      publicAssets: [
        ...existingOutput.publicAssets,
        ...finalOutput.publicAssets
      ]
    },
    manifest: newManifest,
    warnings: manifestWarnings
  };
}

// src/core/utils/building/internal-build.ts
import { relative as relative6 } from "node:path";

// src/core/utils/validation.ts
function validateEntrypoints(entrypoints) {
  const errors = entrypoints.flatMap((entrypoint) => {
    switch (entrypoint.type) {
      case "content-script":
        return validateContentScriptEntrypoint(entrypoint);
      default:
        return validateBaseEntrypoint(entrypoint);
    }
  });
  let errorCount = 0;
  let warningCount = 0;
  for (const err of errors) {
    if (err.type === "warning")
      warningCount++;
    else
      errorCount++;
  }
  return {
    errors,
    errorCount,
    warningCount
  };
}
function validateContentScriptEntrypoint(definition) {
  const errors = validateBaseEntrypoint(definition);
  if (definition.options.matches == null) {
    errors.push({
      type: "error",
      message: "`matches` is required",
      value: definition.options.matches,
      entrypoint: definition
    });
  }
  return errors;
}
function validateBaseEntrypoint(definition) {
  const errors = [];
  if (definition.options.exclude != null && !Array.isArray(definition.options.exclude)) {
    errors.push({
      type: "error",
      message: "`exclude` must be an array of browser names",
      value: definition.options.exclude,
      entrypoint: definition
    });
  }
  if (definition.options.include != null && !Array.isArray(definition.options.include)) {
    errors.push({
      type: "error",
      message: "`include` must be an array of browser names",
      value: definition.options.include,
      entrypoint: definition
    });
  }
  return errors;
}
var ValidationError = class extends Error {
};

// src/core/utils/building/internal-build.ts
import consola3 from "consola";

// src/core/utils/exec.ts
import managePath from "manage-path";
import { resolve as resolve13 } from "node:path";
var managedPath = managePath(process.env);
var exec = async (file, args, options) => {
  managedPath.restore();
  managedPath.push(
    resolve13(wxt.config.root, "node_modules/wxt/node_modules/.bin")
  );
  const { execa } = await import("./execa-Y2EWTC4S.js");
  return await execa(file, args, options);
};

// src/core/utils/building/internal-build.ts
async function internalBuild() {
  await wxt.hooks.callHook("build:before", wxt);
  const verb = wxt.config.command === "serve" ? "Pre-rendering" : "Building";
  const target = `${wxt.config.browser}-mv${wxt.config.manifestVersion}`;
  wxt.logger.info(
    `${verb} ${pc5.cyan(target)} for ${pc5.cyan(wxt.config.mode)} with ${pc5.green(
      `${wxt.config.builder.name} ${wxt.config.builder.version}`
    )}`
  );
  const startTime = Date.now();
  await fs12.rm(wxt.config.outDir, { recursive: true, force: true });
  await fs12.ensureDir(wxt.config.outDir);
  const entrypoints = await findEntrypoints();
  wxt.logger.debug("Detected entrypoints:", entrypoints);
  const validationResults = validateEntrypoints(entrypoints);
  if (validationResults.errorCount + validationResults.warningCount > 0) {
    printValidationResults(validationResults);
  }
  if (validationResults.errorCount > 0) {
    throw new ValidationError(`Entrypoint validation failed`, {
      cause: validationResults
    });
  }
  const groups = groupEntrypoints(entrypoints);
  await wxt.hooks.callHook("entrypoints:grouped", wxt, groups);
  const { output, warnings } = await rebuild(entrypoints, groups, void 0);
  await wxt.hooks.callHook("build:done", wxt, output);
  await printBuildSummary(
    wxt.logger.success,
    `Built extension in ${formatDuration(Date.now() - startTime)}`,
    output
  );
  for (const warning of warnings) {
    wxt.logger.warn(...warning);
  }
  if (wxt.config.analysis.enabled) {
    await combineAnalysisStats();
    const statsPath = relative6(wxt.config.root, wxt.config.analysis.outputFile);
    wxt.logger.info(
      `Analysis complete:
  ${pc5.gray("\u2514\u2500")} ${pc5.yellow(statsPath)}`
    );
  }
  return output;
}
async function combineAnalysisStats() {
  const unixFiles = await glob3(`${wxt.config.analysis.outputName}-*.json`, {
    cwd: wxt.config.analysis.outputDir,
    absolute: true
  });
  const absolutePaths = unixFiles.map(unnormalizePath);
  await exec(
    "rollup-plugin-visualizer",
    [
      ...absolutePaths,
      "--template",
      wxt.config.analysis.template,
      "--filename",
      wxt.config.analysis.outputFile
    ],
    { cwd: wxt.config.root, stdio: "inherit" }
  );
  if (!wxt.config.analysis.keepArtifacts) {
    await Promise.all(absolutePaths.map((statsFile) => fs12.remove(statsFile)));
  }
}
function printValidationResults({
  errorCount,
  errors,
  warningCount
}) {
  (errorCount > 0 ? wxt.logger.error : wxt.logger.warn)(
    `Entrypoint validation failed: ${errorCount} error${errorCount === 1 ? "" : "s"}, ${warningCount} warning${warningCount === 1 ? "" : "s"}`
  );
  const cwd = process.cwd();
  const entrypointErrors = errors.reduce((map, error) => {
    const entryErrors = map.get(error.entrypoint) ?? [];
    entryErrors.push(error);
    map.set(error.entrypoint, entryErrors);
    return map;
  }, /* @__PURE__ */ new Map());
  Array.from(entrypointErrors.entries()).forEach(([entrypoint, errors2]) => {
    consola3.log(relative6(cwd, entrypoint.inputPath));
    console.log();
    errors2.forEach((err) => {
      const type = err.type === "error" ? pc5.red("ERROR") : pc5.yellow("WARN");
      const recieved = pc5.dim(`(recieved: ${JSON.stringify(err.value)})`);
      consola3.log(`  - ${type} ${err.message} ${recieved}`);
    });
    console.log();
  });
}

// src/core/build.ts
async function build(config) {
  await registerWxt("build", config);
  return await internalBuild();
}

// src/core/clean.ts
import path6 from "node:path";
import glob4 from "fast-glob";
import fs13 from "fs-extra";
import { consola as consola4 } from "consola";
import pc6 from "picocolors";
async function clean(root = process.cwd()) {
  consola4.info("Cleaning Project");
  const tempDirs = [
    "node_modules/.vite",
    "node_modules/.cache",
    "**/.wxt",
    ".output/*"
  ];
  consola4.debug("Looking for:", tempDirs.map(pc6.cyan).join(", "));
  const directories = await glob4(tempDirs, {
    cwd: path6.resolve(root),
    absolute: true,
    onlyDirectories: true,
    deep: 2
  });
  if (directories.length === 0) {
    consola4.debug("No generated files found.");
    return;
  }
  consola4.debug(
    "Found:",
    directories.map((dir) => pc6.cyan(path6.relative(root, dir))).join(", ")
  );
  for (const directory of directories) {
    await fs13.rm(directory, { force: true, recursive: true });
    consola4.debug("Deleted " + pc6.cyan(path6.relative(root, directory)));
  }
}

// src/core/runners/wsl.ts
import { relative as relative7 } from "node:path";
function createWslRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot open browser when using WSL. Load "${relative7(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/web-ext.ts
import defu3 from "defu";
function createWebExtRunner() {
  let runner;
  return {
    async openBrowser() {
      const startTime = Date.now();
      if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
        throw Error(
          "Dev mode does not support Firefox MV3. For alternatives, see https://github.com/wxt-dev/wxt/issues/230#issuecomment-1806881653"
        );
      }
      const webExtLogger = await import("web-ext-run/util/logger");
      webExtLogger.consoleStream.write = ({ level, msg, name }) => {
        if (level >= ERROR_LOG_LEVEL)
          wxt.logger.error(name, msg);
        if (level >= WARN_LOG_LEVEL)
          wxt.logger.warn(msg);
      };
      const wxtUserConfig = wxt.config.runnerConfig.config;
      const userConfig = {
        console: wxtUserConfig?.openConsole,
        devtools: wxtUserConfig?.openDevtools,
        startUrl: wxtUserConfig?.startUrls,
        ...wxt.config.browser === "firefox" ? {
          firefox: wxtUserConfig?.binaries?.firefox,
          firefoxProfile: wxtUserConfig?.firefoxProfile,
          prefs: wxtUserConfig?.firefoxPrefs,
          args: wxtUserConfig?.firefoxArgs
        } : {
          chromiumBinary: wxtUserConfig?.binaries?.[wxt.config.browser],
          chromiumProfile: wxtUserConfig?.chromiumProfile,
          chromiumPref: defu3(
            wxtUserConfig?.chromiumPref,
            DEFAULT_CHROMIUM_PREFS
          ),
          args: wxtUserConfig?.chromiumArgs
        }
      };
      const finalConfig = {
        ...userConfig,
        target: wxt.config.browser === "firefox" ? "firefox-desktop" : "chromium",
        sourceDir: wxt.config.outDir,
        // WXT handles reloads, so disable auto-reload behaviors in web-ext
        noReload: true,
        noInput: true
      };
      const options = {
        // Don't call `process.exit(0)` after starting web-ext
        shouldExitProgram: false
      };
      wxt.logger.debug("web-ext config:", finalConfig);
      wxt.logger.debug("web-ext options:", options);
      const webExt = await import("web-ext-run");
      runner = await webExt.default.cmd.run(finalConfig, options);
      const duration = Date.now() - startTime;
      wxt.logger.success(`Opened browser in ${formatDuration(duration)}`);
    },
    async closeBrowser() {
      return await runner?.exit();
    }
  };
}
var WARN_LOG_LEVEL = 40;
var ERROR_LOG_LEVEL = 50;
var DEFAULT_CHROMIUM_PREFS = {
  devtools: {
    synced_preferences_sync_disabled: {
      // Remove content scripts from sourcemap debugger ignore list so stack traces
      // and log locations show up properly, see:
      // https://github.com/wxt-dev/wxt/issues/236#issuecomment-1915364520
      skipContentScripts: false
    }
  }
};

// src/core/runners/safari.ts
import { relative as relative8 } from "node:path";
function createSafariRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot Safari using web-ext. Load "${relative8(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/manual.ts
import { relative as relative9 } from "node:path";
function createManualRunner() {
  return {
    async openBrowser() {
      wxt.logger.info(
        `Load "${relative9(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/utils/wsl.ts
async function isWsl() {
  const { default: isWsl2 } = await import("is-wsl");
  return isWsl2;
}

// src/core/runners/index.ts
async function createExtensionRunner() {
  if (wxt.config.browser === "safari")
    return createSafariRunner();
  if (await isWsl())
    return createWslRunner();
  if (wxt.config.runnerConfig.config?.disabled)
    return createManualRunner();
  return createWebExtRunner();
}

// src/core/create-server.ts
import { consola as consola5 } from "consola";
import { Mutex } from "async-mutex";
import pc7 from "picocolors";
import { relative as relative10 } from "node:path";
async function createServer(inlineConfig) {
  const port = await getPort();
  const hostname = "localhost";
  const origin = `http://${hostname}:${port}`;
  const serverInfo = {
    port,
    hostname,
    origin
  };
  const buildAndOpenBrowser = async () => {
    server.currentOutput = await internalBuild();
    try {
      server.watcher.add(getExternalOutputDependencies(server));
    } catch (err) {
      wxt.config.logger.warn("Failed to register additional file paths:", err);
    }
    await runner.openBrowser();
  };
  const closeAndRecreateRunner = async () => {
    await runner.closeBrowser();
    await wxt.reloadConfig();
    runner = await createExtensionRunner();
  };
  const server = {
    ...serverInfo,
    get watcher() {
      return builderServer.watcher;
    },
    get ws() {
      return builderServer.ws;
    },
    currentOutput: void 0,
    async start() {
      await builderServer.listen();
      wxt.logger.success(`Started dev server @ ${serverInfo.origin}`);
      await buildAndOpenBrowser();
    },
    async stop() {
      await runner.closeBrowser();
      await builderServer.close();
    },
    async restart() {
      await closeAndRecreateRunner();
      await buildAndOpenBrowser();
    },
    transformHtml(url, html, originalUrl) {
      return builderServer.transformHtml(url, html, originalUrl);
    },
    reloadContentScript(contentScript) {
      server.ws.send("wxt:reload-content-script", contentScript);
    },
    reloadPage(path8) {
      server.ws.send("wxt:reload-page", path8);
    },
    reloadExtension() {
      server.ws.send("wxt:reload-extension");
    },
    async restartBrowser() {
      await closeAndRecreateRunner();
      await runner.openBrowser();
    }
  };
  await registerWxt("serve", inlineConfig, server);
  let [runner, builderServer] = await Promise.all([
    createExtensionRunner(),
    wxt.config.builder.createServer(server)
  ]);
  server.ws.on("wxt:background-initialized", () => {
    if (server.currentOutput == null)
      return;
    reloadContentScripts(server.currentOutput.steps, server);
  });
  const reloadOnChange = createFileReloader(server);
  server.watcher.on("all", reloadOnChange);
  return server;
}
async function getPort() {
  const { default: getPort2, portNumbers } = await import("get-port");
  return await getPort2({ port: portNumbers(3e3, 3010) });
}
function createFileReloader(server) {
  const fileChangedMutex = new Mutex();
  const changeQueue = [];
  return async (event, path8) => {
    await wxt.reloadConfig();
    if (path8.startsWith(wxt.config.outBaseDir))
      return;
    changeQueue.push([event, path8]);
    await fileChangedMutex.runExclusive(async () => {
      if (server.currentOutput == null)
        return;
      const fileChanges = changeQueue.splice(0, changeQueue.length).map(([_, file]) => file);
      if (fileChanges.length === 0)
        return;
      const changes = detectDevChanges(fileChanges, server.currentOutput);
      if (changes.type === "no-change")
        return;
      if (changes.type === "full-restart") {
        wxt.logger.info("Config changed, restarting server...");
        server.restart();
        return;
      }
      if (changes.type === "browser-restart") {
        wxt.logger.info("Runner config changed, restarting browser...");
        server.restartBrowser();
        return;
      }
      wxt.logger.info(
        `Changed: ${Array.from(new Set(fileChanges)).map((file) => pc7.dim(relative10(wxt.config.root, file))).join(", ")}`
      );
      const allEntrypoints = await findEntrypoints();
      const { output: newOutput } = await rebuild(
        allEntrypoints,
        // TODO: this excludes new entrypoints, so they're not built until the dev command is restarted
        changes.rebuildGroups,
        changes.cachedOutput
      );
      server.currentOutput = newOutput;
      switch (changes.type) {
        case "extension-reload":
          server.reloadExtension();
          consola5.success(`Reloaded extension`);
          break;
        case "html-reload":
          const { reloadedNames } = reloadHtmlPages(
            changes.rebuildGroups,
            server
          );
          consola5.success(`Reloaded: ${getFilenameList(reloadedNames)}`);
          break;
        case "content-script-reload":
          reloadContentScripts(changes.changedSteps, server);
          const rebuiltNames = changes.rebuildGroups.flat().map((entry) => entry.name);
          consola5.success(`Reloaded: ${getFilenameList(rebuiltNames)}`);
          break;
      }
    });
  };
}
function reloadContentScripts(steps, server) {
  if (wxt.config.manifestVersion === 3) {
    steps.forEach((step) => {
      if (server.currentOutput == null)
        return;
      const entry = step.entrypoints;
      if (Array.isArray(entry) || entry.type !== "content-script")
        return;
      const js = [getEntrypointBundlePath(entry, wxt.config.outDir, ".js")];
      const cssMap = getContentScriptsCssMap(server.currentOutput, [entry]);
      const css = getContentScriptCssFiles([entry], cssMap);
      server.reloadContentScript(
        mapWxtOptionsToRegisteredContentScript(entry.options, js, css)
      );
    });
  } else {
    server.reloadExtension();
  }
}
function reloadHtmlPages(groups, server) {
  const htmlEntries = groups.flat().filter(isHtmlEntrypoint);
  htmlEntries.forEach((entry) => {
    const path8 = getEntrypointBundlePath(entry, wxt.config.outDir, ".html");
    server.reloadPage(path8);
  });
  return {
    reloadedNames: htmlEntries.map((entry) => entry.name)
  };
}
function getFilenameList(names) {
  return names.map((name) => {
    return pc7.cyan(name);
  }).join(pc7.dim(", "));
}
function getExternalOutputDependencies(server) {
  return server.currentOutput?.steps.flatMap((step, i) => {
    if (Array.isArray(step.entrypoints) && i === 0) {
      return [];
    }
    return step.chunks.flatMap((chunk) => {
      if (chunk.type === "asset")
        return [];
      return chunk.moduleIds;
    });
  }).filter(
    (file) => !file.includes("node_modules") && !file.startsWith("\0")
  ).map(unnormalizePath).filter((file) => !file.startsWith(wxt.config.root)) ?? [];
}

// src/core/initialize.ts
import prompts from "prompts";
import { consola as consola6 } from "consola";
import { downloadTemplate } from "giget";
import fs14 from "fs-extra";
import path7 from "node:path";
import pc8 from "picocolors";
async function initialize(options) {
  consola6.info("Initalizing new project");
  const templates = await listTemplates();
  const defaultTemplate = templates.find(
    (template) => template.name === options.template?.toLowerCase().trim()
  );
  const input = await prompts(
    [
      {
        name: "directory",
        type: () => options.directory == null ? "text" : void 0,
        message: "Project Directory",
        initial: options.directory
      },
      {
        name: "template",
        type: () => defaultTemplate == null ? "select" : void 0,
        message: "Choose a template",
        choices: templates.map((template) => ({
          title: TEMPLATE_COLORS[template.name]?.(template.name) ?? template.name,
          value: template
        }))
      },
      {
        name: "packageManager",
        type: () => options.packageManager == null ? "select" : void 0,
        message: "Package Manager",
        choices: [
          { title: pc8.red("npm"), value: "npm" },
          { title: pc8.yellow("pnpm"), value: "pnpm" },
          { title: pc8.cyan("yarn"), value: "yarn" },
          {
            title: `${pc8.magenta("bun")}${pc8.gray(" (experimental)")}`,
            value: "bun"
          }
        ]
      }
    ],
    {
      onCancel: () => process.exit(1)
    }
  );
  input.directory ??= options.directory;
  input.template ??= defaultTemplate;
  input.packageManager ??= options.packageManager;
  await cloneProject(input);
  const cdPath = path7.relative(process.cwd(), path7.resolve(input.directory));
  console.log();
  consola6.log(
    `\u2728 WXT project created with the ${TEMPLATE_COLORS[input.template.name]?.(input.template.name) ?? input.template.name} template.`
  );
  console.log();
  consola6.log("Next steps:");
  let step = 0;
  if (cdPath !== "")
    consola6.log(`  ${++step}.`, pc8.cyan(`cd ${cdPath}`));
  consola6.log(`  ${++step}.`, pc8.cyan(`${input.packageManager} install`));
  console.log();
}
async function listTemplates() {
  try {
    const res = await fetch("https://ungh.cc/repos/wxt-dev/wxt/files/main");
    if (res.status >= 300)
      throw Error(`Request failed with status ${res.status} ${res.statusText}`);
    const data = await res.json();
    return data.files.map((item) => item.path.match(/templates\/(.+)\/package\.json/)?.[1]).filter((name) => name != null).map((name) => ({ name, path: `templates/${name}` })).sort((l, r) => {
      const lWeight = TEMPLATE_SORT_WEIGHT[l.name] ?? Number.MAX_SAFE_INTEGER;
      const rWeight = TEMPLATE_SORT_WEIGHT[r.name] ?? Number.MAX_SAFE_INTEGER;
      const diff = lWeight - rWeight;
      if (diff !== 0)
        return diff;
      return l.name.localeCompare(r.name);
    });
  } catch (err) {
    throw Error(`Cannot load templates: ${JSON.stringify(err, null, 2)}`);
  }
}
async function cloneProject({
  directory,
  template,
  packageManager
}) {
  const { default: ora } = await import("ora");
  const spinner = ora("Downloading template").start();
  try {
    await downloadTemplate(`gh:wxt-dev/wxt/${template.path}`, {
      dir: directory,
      force: true
    });
    await fs14.move(
      path7.join(directory, "_gitignore"),
      path7.join(directory, ".gitignore")
    ).catch(
      (err) => consola6.warn("Failed to move _gitignore to .gitignore:", err)
    );
    spinner.succeed();
  } catch (err) {
    spinner.fail();
    throw Error(`Failed to setup new project: ${JSON.stringify(err, null, 2)}`);
  }
}
var TEMPLATE_COLORS = {
  vanilla: pc8.blue,
  vue: pc8.green,
  react: pc8.cyan,
  svelte: pc8.red,
  solid: pc8.blue
};
var TEMPLATE_SORT_WEIGHT = {
  vanilla: 0,
  vue: 1,
  react: 2
};

// src/core/prepare.ts
async function prepare(config) {
  await registerWxt("build", config);
  wxt.logger.info("Generating types...");
  const entrypoints = await findEntrypoints();
  await generateTypesDir(entrypoints);
}

// src/core/zip.ts
import zipdir from "zip-dir";
import { dirname as dirname5, relative as relative11, resolve as resolve14 } from "node:path";
import fs15 from "fs-extra";
import { minimatch as minimatch2 } from "minimatch";
async function zip(config) {
  await registerWxt("build", config);
  const output = await internalBuild();
  const start = Date.now();
  wxt.logger.info("Zipping extension...");
  const zipFiles = [];
  const projectName = wxt.config.zip.name ?? kebabCaseAlphanumeric(
    (await getPackageJson())?.name || dirname5(process.cwd())
  );
  const applyTemplate = (template) => template.replaceAll("{{name}}", projectName).replaceAll("{{browser}}", wxt.config.browser).replaceAll(
    "{{version}}",
    output.manifest.version_name ?? output.manifest.version
  ).replaceAll("{{manifestVersion}}", `mv${wxt.config.manifestVersion}`);
  await fs15.ensureDir(wxt.config.outBaseDir);
  const outZipFilename = applyTemplate(wxt.config.zip.artifactTemplate);
  const outZipPath = resolve14(wxt.config.outBaseDir, outZipFilename);
  await zipdir(wxt.config.outDir, {
    saveTo: outZipPath
  });
  zipFiles.push(outZipPath);
  if (wxt.config.browser === "firefox") {
    const sourcesZipFilename = applyTemplate(wxt.config.zip.sourcesTemplate);
    const sourcesZipPath = resolve14(wxt.config.outBaseDir, sourcesZipFilename);
    await zipdir(wxt.config.zip.sourcesRoot, {
      saveTo: sourcesZipPath,
      filter(path8) {
        const relativePath = relative11(wxt.config.zip.sourcesRoot, path8);
        return wxt.config.zip.includeSources.some(
          (pattern) => minimatch2(relativePath, pattern)
        ) || !wxt.config.zip.excludeSources.some(
          (pattern) => minimatch2(relativePath, pattern)
        );
      }
    });
    zipFiles.push(sourcesZipPath);
  }
  await printFileList(
    wxt.logger.success,
    `Zipped extension in ${formatDuration(Date.now() - start)}`,
    wxt.config.outBaseDir,
    zipFiles
  );
  return zipFiles;
}

// src/cli/cli-utils.ts
import consola7, { LogLevels as LogLevels2 } from "consola";
function wrapAction(cb, options) {
  return async (...args) => {
    const isDebug = !!args.find((arg) => arg?.debug);
    if (isDebug) {
      consola7.level = LogLevels2.debug;
    }
    const startTime = Date.now();
    try {
      printHeader();
      const status = await cb(...args);
      if (!status?.isOngoing && !options?.disableFinishedLog)
        consola7.success(
          `Finished in ${formatDuration(Date.now() - startTime)}`
        );
    } catch (err) {
      consola7.fail(
        `Command failed after ${formatDuration(Date.now() - startTime)}`
      );
      if (err instanceof ValidationError) {
      } else {
        consola7.error(err);
      }
      process.exit(1);
    }
  };
}
function getArrayFromFlags(flags, name) {
  const array = [flags[name]].flat();
  const result = array.filter((item) => item != null);
  return result.length ? result : void 0;
}
var aliasCommandNames = /* @__PURE__ */ new Set();
function createAliasedCommand(base, name, alias, docsUrl) {
  const aliasedCommand = base.command(name, `Alias for ${alias} (${docsUrl})`).allowUnknownOptions().action(async () => {
    try {
      await registerWxt("build");
      const args = process.argv.slice(
        process.argv.indexOf(aliasedCommand.name) + 1
      );
      await exec(alias, args, {
        stdio: "inherit"
      });
    } catch {
      process.exit(1);
    }
  });
  aliasCommandNames.add(aliasedCommand.name);
}
function isAliasedCommand(command) {
  return !!command && aliasCommandNames.has(command.name);
}

// src/cli/commands.ts
var cli = cac("wxt");
cli.option("--debug", "enable debug mode");
cli.command("[root]", "start dev server").option("-c, --config <file>", "use specified config file").option("-m, --mode <mode>", "set env mode").option("-b, --browser <browser>", "specify a browser").option(
  "-e, --filter-entrypoint <entrypoint>",
  "only build specific entrypoints",
  {
    type: []
  }
).option("--mv3", "target manifest v3").option("--mv2", "target manifest v2").action(
  wrapAction(async (root, flags) => {
    const server = await createServer({
      root,
      mode: flags.mode,
      browser: flags.browser,
      manifestVersion: flags.mv3 ? 3 : flags.mv2 ? 2 : void 0,
      configFile: flags.config,
      debug: flags.debug,
      filterEntrypoints: getArrayFromFlags(flags, "filterEntrypoint")
    });
    await server.start();
    return { isOngoing: true };
  })
);
cli.command("build [root]", "build for production").option("-c, --config <file>", "use specified config file").option("-m, --mode <mode>", "set env mode").option("-b, --browser <browser>", "specify a browser").option(
  "-e, --filter-entrypoint <entrypoint>",
  "only build specific entrypoints",
  {
    type: []
  }
).option("--mv3", "target manifest v3").option("--mv2", "target manifest v2").option("--analyze", "visualize extension bundle").action(
  wrapAction(async (root, flags) => {
    await build({
      root,
      mode: flags.mode,
      browser: flags.browser,
      manifestVersion: flags.mv3 ? 3 : flags.mv2 ? 2 : void 0,
      configFile: flags.config,
      debug: flags.debug,
      analysis: flags.analyze ? { enabled: true } : void 0,
      filterEntrypoints: getArrayFromFlags(flags, "filterEntrypoint")
    });
  })
);
cli.command("zip [root]", "build for production and zip output").option("-c, --config <file>", "use specified config file").option("-m, --mode <mode>", "set env mode").option("-b, --browser <browser>", "specify a browser").option("--mv3", "target manifest v3").option("--mv2", "target manifest v2").action(
  wrapAction(async (root, flags) => {
    await zip({
      root,
      mode: flags.mode,
      browser: flags.browser,
      manifestVersion: flags.mv3 ? 3 : flags.mv2 ? 2 : void 0,
      configFile: flags.config,
      debug: flags.debug
    });
  })
);
cli.command("prepare [root]", "prepare typescript project").option("-c, --config <file>", "use specified config file").action(
  wrapAction(async (root, flags) => {
    await prepare({
      root,
      configFile: flags.config,
      debug: flags.debug
    });
  })
);
cli.command("clean [root]", "clean generated files and caches").alias("cleanup").action(
  wrapAction(async (root, flags) => {
    await clean(root);
  })
);
cli.command("init [directory]", "initialize a new project").option("-t, --template <template>", "template to use").option("--pm <packageManager>", "which package manager to use").action(
  wrapAction(
    async (directory, flags) => {
      await initialize({
        directory,
        template: flags.template,
        packageManager: flags.pm
      });
    },
    { disableFinishedLog: true }
  )
);
createAliasedCommand(
  cli,
  "submit",
  "publish-extension",
  "https://www.npmjs.com/publish-browser-extension"
);
var commands_default = cli;

// src/cli/index.ts
process.env.VITE_CJS_IGNORE_WARNING = "true";
commands_default.parse(process.argv, { run: false });
if (!isAliasedCommand(commands_default.matchedCommand)) {
  commands_default.help();
  commands_default.version(version);
  commands_default.parse(process.argv, { run: false });
}
await commands_default.runMatchedCommand();
