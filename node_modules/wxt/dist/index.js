import {
  detectDevChanges,
  findEntrypoints,
  formatDuration,
  generateTypesDir,
  getContentScriptCssFiles,
  getContentScriptsCssMap,
  getEntrypointBundlePath,
  getPackageJson,
  internalBuild,
  isHtmlEntrypoint,
  kebabCaseAlphanumeric,
  mapWxtOptionsToRegisteredContentScript,
  printFileList,
  rebuild,
  registerWxt,
  unnormalizePath,
  version,
  wxt
} from "./chunk-YH7RSTGT.js";
import "./chunk-VBXJIVYU.js";

// src/core/build.ts
async function build(config) {
  await registerWxt("build", config);
  return await internalBuild();
}

// src/core/clean.ts
import path from "node:path";
import glob from "fast-glob";
import fs from "fs-extra";
import { consola } from "consola";
import pc from "picocolors";
async function clean(root = process.cwd()) {
  consola.info("Cleaning Project");
  const tempDirs = [
    "node_modules/.vite",
    "node_modules/.cache",
    "**/.wxt",
    ".output/*"
  ];
  consola.debug("Looking for:", tempDirs.map(pc.cyan).join(", "));
  const directories = await glob(tempDirs, {
    cwd: path.resolve(root),
    absolute: true,
    onlyDirectories: true,
    deep: 2
  });
  if (directories.length === 0) {
    consola.debug("No generated files found.");
    return;
  }
  consola.debug(
    "Found:",
    directories.map((dir) => pc.cyan(path.relative(root, dir))).join(", ")
  );
  for (const directory of directories) {
    await fs.rm(directory, { force: true, recursive: true });
    consola.debug("Deleted " + pc.cyan(path.relative(root, directory)));
  }
}

// src/core/define-config.ts
function defineConfig(config) {
  return config;
}

// src/core/define-runner-config.ts
function defineRunnerConfig(config) {
  return config;
}

// src/core/runners/wsl.ts
import { relative } from "node:path";
function createWslRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot open browser when using WSL. Load "${relative(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/web-ext.ts
import defu from "defu";
function createWebExtRunner() {
  let runner;
  return {
    async openBrowser() {
      const startTime = Date.now();
      if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
        throw Error(
          "Dev mode does not support Firefox MV3. For alternatives, see https://github.com/wxt-dev/wxt/issues/230#issuecomment-1806881653"
        );
      }
      const webExtLogger = await import("web-ext-run/util/logger");
      webExtLogger.consoleStream.write = ({ level, msg, name }) => {
        if (level >= ERROR_LOG_LEVEL)
          wxt.logger.error(name, msg);
        if (level >= WARN_LOG_LEVEL)
          wxt.logger.warn(msg);
      };
      const wxtUserConfig = wxt.config.runnerConfig.config;
      const userConfig = {
        console: wxtUserConfig?.openConsole,
        devtools: wxtUserConfig?.openDevtools,
        startUrl: wxtUserConfig?.startUrls,
        ...wxt.config.browser === "firefox" ? {
          firefox: wxtUserConfig?.binaries?.firefox,
          firefoxProfile: wxtUserConfig?.firefoxProfile,
          prefs: wxtUserConfig?.firefoxPrefs,
          args: wxtUserConfig?.firefoxArgs
        } : {
          chromiumBinary: wxtUserConfig?.binaries?.[wxt.config.browser],
          chromiumProfile: wxtUserConfig?.chromiumProfile,
          chromiumPref: defu(
            wxtUserConfig?.chromiumPref,
            DEFAULT_CHROMIUM_PREFS
          ),
          args: wxtUserConfig?.chromiumArgs
        }
      };
      const finalConfig = {
        ...userConfig,
        target: wxt.config.browser === "firefox" ? "firefox-desktop" : "chromium",
        sourceDir: wxt.config.outDir,
        // WXT handles reloads, so disable auto-reload behaviors in web-ext
        noReload: true,
        noInput: true
      };
      const options = {
        // Don't call `process.exit(0)` after starting web-ext
        shouldExitProgram: false
      };
      wxt.logger.debug("web-ext config:", finalConfig);
      wxt.logger.debug("web-ext options:", options);
      const webExt = await import("web-ext-run");
      runner = await webExt.default.cmd.run(finalConfig, options);
      const duration = Date.now() - startTime;
      wxt.logger.success(`Opened browser in ${formatDuration(duration)}`);
    },
    async closeBrowser() {
      return await runner?.exit();
    }
  };
}
var WARN_LOG_LEVEL = 40;
var ERROR_LOG_LEVEL = 50;
var DEFAULT_CHROMIUM_PREFS = {
  devtools: {
    synced_preferences_sync_disabled: {
      // Remove content scripts from sourcemap debugger ignore list so stack traces
      // and log locations show up properly, see:
      // https://github.com/wxt-dev/wxt/issues/236#issuecomment-1915364520
      skipContentScripts: false
    }
  }
};

// src/core/runners/safari.ts
import { relative as relative2 } from "node:path";
function createSafariRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot Safari using web-ext. Load "${relative2(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/manual.ts
import { relative as relative3 } from "node:path";
function createManualRunner() {
  return {
    async openBrowser() {
      wxt.logger.info(
        `Load "${relative3(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/utils/wsl.ts
async function isWsl() {
  const { default: isWsl2 } = await import("is-wsl");
  return isWsl2;
}

// src/core/runners/index.ts
async function createExtensionRunner() {
  if (wxt.config.browser === "safari")
    return createSafariRunner();
  if (await isWsl())
    return createWslRunner();
  if (wxt.config.runnerConfig.config?.disabled)
    return createManualRunner();
  return createWebExtRunner();
}

// src/core/create-server.ts
import { consola as consola2 } from "consola";
import { Mutex } from "async-mutex";
import pc2 from "picocolors";
import { relative as relative4 } from "node:path";
async function createServer(inlineConfig) {
  const port = await getPort();
  const hostname = "localhost";
  const origin = `http://${hostname}:${port}`;
  const serverInfo = {
    port,
    hostname,
    origin
  };
  const buildAndOpenBrowser = async () => {
    server.currentOutput = await internalBuild();
    try {
      server.watcher.add(getExternalOutputDependencies(server));
    } catch (err) {
      wxt.config.logger.warn("Failed to register additional file paths:", err);
    }
    await runner.openBrowser();
  };
  const closeAndRecreateRunner = async () => {
    await runner.closeBrowser();
    await wxt.reloadConfig();
    runner = await createExtensionRunner();
  };
  const server = {
    ...serverInfo,
    get watcher() {
      return builderServer.watcher;
    },
    get ws() {
      return builderServer.ws;
    },
    currentOutput: void 0,
    async start() {
      await builderServer.listen();
      wxt.logger.success(`Started dev server @ ${serverInfo.origin}`);
      await buildAndOpenBrowser();
    },
    async stop() {
      await runner.closeBrowser();
      await builderServer.close();
    },
    async restart() {
      await closeAndRecreateRunner();
      await buildAndOpenBrowser();
    },
    transformHtml(url, html, originalUrl) {
      return builderServer.transformHtml(url, html, originalUrl);
    },
    reloadContentScript(contentScript) {
      server.ws.send("wxt:reload-content-script", contentScript);
    },
    reloadPage(path3) {
      server.ws.send("wxt:reload-page", path3);
    },
    reloadExtension() {
      server.ws.send("wxt:reload-extension");
    },
    async restartBrowser() {
      await closeAndRecreateRunner();
      await runner.openBrowser();
    }
  };
  await registerWxt("serve", inlineConfig, server);
  let [runner, builderServer] = await Promise.all([
    createExtensionRunner(),
    wxt.config.builder.createServer(server)
  ]);
  server.ws.on("wxt:background-initialized", () => {
    if (server.currentOutput == null)
      return;
    reloadContentScripts(server.currentOutput.steps, server);
  });
  const reloadOnChange = createFileReloader(server);
  server.watcher.on("all", reloadOnChange);
  return server;
}
async function getPort() {
  const { default: getPort2, portNumbers } = await import("get-port");
  return await getPort2({ port: portNumbers(3e3, 3010) });
}
function createFileReloader(server) {
  const fileChangedMutex = new Mutex();
  const changeQueue = [];
  return async (event, path3) => {
    await wxt.reloadConfig();
    if (path3.startsWith(wxt.config.outBaseDir))
      return;
    changeQueue.push([event, path3]);
    await fileChangedMutex.runExclusive(async () => {
      if (server.currentOutput == null)
        return;
      const fileChanges = changeQueue.splice(0, changeQueue.length).map(([_, file]) => file);
      if (fileChanges.length === 0)
        return;
      const changes = detectDevChanges(fileChanges, server.currentOutput);
      if (changes.type === "no-change")
        return;
      if (changes.type === "full-restart") {
        wxt.logger.info("Config changed, restarting server...");
        server.restart();
        return;
      }
      if (changes.type === "browser-restart") {
        wxt.logger.info("Runner config changed, restarting browser...");
        server.restartBrowser();
        return;
      }
      wxt.logger.info(
        `Changed: ${Array.from(new Set(fileChanges)).map((file) => pc2.dim(relative4(wxt.config.root, file))).join(", ")}`
      );
      const allEntrypoints = await findEntrypoints();
      const { output: newOutput } = await rebuild(
        allEntrypoints,
        // TODO: this excludes new entrypoints, so they're not built until the dev command is restarted
        changes.rebuildGroups,
        changes.cachedOutput
      );
      server.currentOutput = newOutput;
      switch (changes.type) {
        case "extension-reload":
          server.reloadExtension();
          consola2.success(`Reloaded extension`);
          break;
        case "html-reload":
          const { reloadedNames } = reloadHtmlPages(
            changes.rebuildGroups,
            server
          );
          consola2.success(`Reloaded: ${getFilenameList(reloadedNames)}`);
          break;
        case "content-script-reload":
          reloadContentScripts(changes.changedSteps, server);
          const rebuiltNames = changes.rebuildGroups.flat().map((entry) => entry.name);
          consola2.success(`Reloaded: ${getFilenameList(rebuiltNames)}`);
          break;
      }
    });
  };
}
function reloadContentScripts(steps, server) {
  if (wxt.config.manifestVersion === 3) {
    steps.forEach((step) => {
      if (server.currentOutput == null)
        return;
      const entry = step.entrypoints;
      if (Array.isArray(entry) || entry.type !== "content-script")
        return;
      const js = [getEntrypointBundlePath(entry, wxt.config.outDir, ".js")];
      const cssMap = getContentScriptsCssMap(server.currentOutput, [entry]);
      const css = getContentScriptCssFiles([entry], cssMap);
      server.reloadContentScript(
        mapWxtOptionsToRegisteredContentScript(entry.options, js, css)
      );
    });
  } else {
    server.reloadExtension();
  }
}
function reloadHtmlPages(groups, server) {
  const htmlEntries = groups.flat().filter(isHtmlEntrypoint);
  htmlEntries.forEach((entry) => {
    const path3 = getEntrypointBundlePath(entry, wxt.config.outDir, ".html");
    server.reloadPage(path3);
  });
  return {
    reloadedNames: htmlEntries.map((entry) => entry.name)
  };
}
function getFilenameList(names) {
  return names.map((name) => {
    return pc2.cyan(name);
  }).join(pc2.dim(", "));
}
function getExternalOutputDependencies(server) {
  return server.currentOutput?.steps.flatMap((step, i) => {
    if (Array.isArray(step.entrypoints) && i === 0) {
      return [];
    }
    return step.chunks.flatMap((chunk) => {
      if (chunk.type === "asset")
        return [];
      return chunk.moduleIds;
    });
  }).filter(
    (file) => !file.includes("node_modules") && !file.startsWith("\0")
  ).map(unnormalizePath).filter((file) => !file.startsWith(wxt.config.root)) ?? [];
}

// src/core/initialize.ts
import prompts from "prompts";
import { consola as consola3 } from "consola";
import { downloadTemplate } from "giget";
import fs2 from "fs-extra";
import path2 from "node:path";
import pc3 from "picocolors";
async function initialize(options) {
  consola3.info("Initalizing new project");
  const templates = await listTemplates();
  const defaultTemplate = templates.find(
    (template) => template.name === options.template?.toLowerCase().trim()
  );
  const input = await prompts(
    [
      {
        name: "directory",
        type: () => options.directory == null ? "text" : void 0,
        message: "Project Directory",
        initial: options.directory
      },
      {
        name: "template",
        type: () => defaultTemplate == null ? "select" : void 0,
        message: "Choose a template",
        choices: templates.map((template) => ({
          title: TEMPLATE_COLORS[template.name]?.(template.name) ?? template.name,
          value: template
        }))
      },
      {
        name: "packageManager",
        type: () => options.packageManager == null ? "select" : void 0,
        message: "Package Manager",
        choices: [
          { title: pc3.red("npm"), value: "npm" },
          { title: pc3.yellow("pnpm"), value: "pnpm" },
          { title: pc3.cyan("yarn"), value: "yarn" },
          {
            title: `${pc3.magenta("bun")}${pc3.gray(" (experimental)")}`,
            value: "bun"
          }
        ]
      }
    ],
    {
      onCancel: () => process.exit(1)
    }
  );
  input.directory ??= options.directory;
  input.template ??= defaultTemplate;
  input.packageManager ??= options.packageManager;
  await cloneProject(input);
  const cdPath = path2.relative(process.cwd(), path2.resolve(input.directory));
  console.log();
  consola3.log(
    `\u2728 WXT project created with the ${TEMPLATE_COLORS[input.template.name]?.(input.template.name) ?? input.template.name} template.`
  );
  console.log();
  consola3.log("Next steps:");
  let step = 0;
  if (cdPath !== "")
    consola3.log(`  ${++step}.`, pc3.cyan(`cd ${cdPath}`));
  consola3.log(`  ${++step}.`, pc3.cyan(`${input.packageManager} install`));
  console.log();
}
async function listTemplates() {
  try {
    const res = await fetch("https://ungh.cc/repos/wxt-dev/wxt/files/main");
    if (res.status >= 300)
      throw Error(`Request failed with status ${res.status} ${res.statusText}`);
    const data = await res.json();
    return data.files.map((item) => item.path.match(/templates\/(.+)\/package\.json/)?.[1]).filter((name) => name != null).map((name) => ({ name, path: `templates/${name}` })).sort((l, r) => {
      const lWeight = TEMPLATE_SORT_WEIGHT[l.name] ?? Number.MAX_SAFE_INTEGER;
      const rWeight = TEMPLATE_SORT_WEIGHT[r.name] ?? Number.MAX_SAFE_INTEGER;
      const diff = lWeight - rWeight;
      if (diff !== 0)
        return diff;
      return l.name.localeCompare(r.name);
    });
  } catch (err) {
    throw Error(`Cannot load templates: ${JSON.stringify(err, null, 2)}`);
  }
}
async function cloneProject({
  directory,
  template,
  packageManager
}) {
  const { default: ora } = await import("ora");
  const spinner = ora("Downloading template").start();
  try {
    await downloadTemplate(`gh:wxt-dev/wxt/${template.path}`, {
      dir: directory,
      force: true
    });
    await fs2.move(
      path2.join(directory, "_gitignore"),
      path2.join(directory, ".gitignore")
    ).catch(
      (err) => consola3.warn("Failed to move _gitignore to .gitignore:", err)
    );
    spinner.succeed();
  } catch (err) {
    spinner.fail();
    throw Error(`Failed to setup new project: ${JSON.stringify(err, null, 2)}`);
  }
}
var TEMPLATE_COLORS = {
  vanilla: pc3.blue,
  vue: pc3.green,
  react: pc3.cyan,
  svelte: pc3.red,
  solid: pc3.blue
};
var TEMPLATE_SORT_WEIGHT = {
  vanilla: 0,
  vue: 1,
  react: 2
};

// src/core/prepare.ts
async function prepare(config) {
  await registerWxt("build", config);
  wxt.logger.info("Generating types...");
  const entrypoints = await findEntrypoints();
  await generateTypesDir(entrypoints);
}

// src/core/zip.ts
import zipdir from "zip-dir";
import { dirname, relative as relative5, resolve } from "node:path";
import fs3 from "fs-extra";
import { minimatch } from "minimatch";
async function zip(config) {
  await registerWxt("build", config);
  const output = await internalBuild();
  const start = Date.now();
  wxt.logger.info("Zipping extension...");
  const zipFiles = [];
  const projectName = wxt.config.zip.name ?? kebabCaseAlphanumeric(
    (await getPackageJson())?.name || dirname(process.cwd())
  );
  const applyTemplate = (template) => template.replaceAll("{{name}}", projectName).replaceAll("{{browser}}", wxt.config.browser).replaceAll(
    "{{version}}",
    output.manifest.version_name ?? output.manifest.version
  ).replaceAll("{{manifestVersion}}", `mv${wxt.config.manifestVersion}`);
  await fs3.ensureDir(wxt.config.outBaseDir);
  const outZipFilename = applyTemplate(wxt.config.zip.artifactTemplate);
  const outZipPath = resolve(wxt.config.outBaseDir, outZipFilename);
  await zipdir(wxt.config.outDir, {
    saveTo: outZipPath
  });
  zipFiles.push(outZipPath);
  if (wxt.config.browser === "firefox") {
    const sourcesZipFilename = applyTemplate(wxt.config.zip.sourcesTemplate);
    const sourcesZipPath = resolve(wxt.config.outBaseDir, sourcesZipFilename);
    await zipdir(wxt.config.zip.sourcesRoot, {
      saveTo: sourcesZipPath,
      filter(path3) {
        const relativePath = relative5(wxt.config.zip.sourcesRoot, path3);
        return wxt.config.zip.includeSources.some(
          (pattern) => minimatch(relativePath, pattern)
        ) || !wxt.config.zip.excludeSources.some(
          (pattern) => minimatch(relativePath, pattern)
        );
      }
    });
    zipFiles.push(sourcesZipPath);
  }
  await printFileList(
    wxt.logger.success,
    `Zipped extension in ${formatDuration(Date.now() - start)}`,
    wxt.config.outBaseDir,
    zipFiles
  );
  return zipFiles;
}
export {
  build,
  clean,
  createServer,
  defineConfig,
  defineRunnerConfig,
  initialize,
  prepare,
  version,
  zip
};
